<!doctype html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Jekyll v3.8.6"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700"><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/css/main.min.css><link rel=stylesheet href=https://blogassets.ismisv.com/css/pay.min.css><link rel=apple-touch-icon href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/apple-touch-icon.png><link rel=icon type=image/png href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/touch-icon.png sizes=192x192><link rel=icon type=image/png href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/images/favicon.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css media=print onload='this.media="all"'><style>body{font-family:lxgw wenkai screen,sans-serif}</style><link type=application/atom+xml rel=alternate href=https://minidump.info/feed.xml title="不那么新的modern C++简要学习笔记"><title>Search - 不那么新的modern C++简要学习笔记</title><meta property="og:title" content="Search"><meta name=description content="学习C++11/14/17/20等的一点记录"><meta property="og:description" content="学习C++11/14/17/20等的一点记录"><link rel=canonical href=https://minidump.info/search/><meta property="og:url" content="https://minidump.info/search/"><meta property="og:site_name" content="不那么新的modern C++简要学习笔记"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebPage","headline":"Search","description":"学习C++11/14/17/20等的一点记录","logo":"https://minidump.info/siteicon.png","url":"https://minidump.info/search/"}</script><script>(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-52744860-1","auto"),ga("send","pageview")</script><header><h1><a href=/><img src=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/images/emblem.svg width=40 height=40 alt="不那么新的modern C++简要学习笔记 logo"></a>
不那么新的modern C++简要学习笔记
<button type=button class=open-nav id=open-nav></button></h1><form action=/search/><input name=q id=search-input placeholder=Search autofocus>
<input type=submit value=Search style=display:none></form><nav class=full-navigation><ul><li class="nav-item top-level"><a href=/>前言</a></ul><ul><li class="nav-item top-level"><a href=/C++11/alignas/>C++11</a><ul><li class=nav-item><a href=/C++11/alignas/>Alignas</a><li class=nav-item><a href=/C++11/alignof/>Alignof</a><li class=nav-item><a href=/C++11/atomic-operations/>原子操作</a><li class=nav-item><a href=/C++11/attributes/>属性</a><li class=nav-item><a href=/C++11/auto/>自动类型推导</a><li class=nav-item><a href=/C++11/c99-preprocessor/>C99兼容预处理器</a><li class=nav-item><a href=/C++11/constexpr/>常量表达式</a><li class=nav-item><a href=/C++11/decltype/>decltype</a><li class=nav-item><a href=/C++11/defaulted-and-deleted-functions/>缺省函数和可删除函数</a><li class=nav-item><a href=/C++11/delegating-constructors/>委托构造函数</a><li class=nav-item><a href=/C++11/dynamic-initialization-and-destruction-with-concurrency/>动态初始化和并发析构（魔法静态）</a><li class=nav-item><a href=/C++11/dynamic-pointer-safety/>动态指针安全（垃圾回收接口）</a><li class=nav-item><a href=/C++11/explicit-conversion-operators/>显式转换操作符</a><li class=nav-item><a href=/C++11/extended-friend-declarations/>扩展的friend声明</a><li class=nav-item><a href=/C++11/extern-template/>外部模板</a><li class=nav-item><a href=/C++11/forward-enum-declarations/>前向声明枚举类型</a><li class=nav-item><a href=/C++11/inheriting-constructors/>继承构造函数</a><li class=nav-item><a href=/C++11/initializer-lists/>初始化列表</a><li class=nav-item><a href=/C++11/inline-namespace/>内联名字空间</a><li class=nav-item><a href=/C++11/lambda/>Lambda表达式</a><li class=nav-item><a href=/C++11/local-and-unnamed-types-as-template-parameters/>本地和匿名类型作为模板参数</a><li class=nav-item><a href=/C++11/long-long/>long long类型</a><li class=nav-item><a href=/C++11/money-time-hexfloat-IO-manipulators/>货币、时间、16进制浮点I/O操作</a><li class=nav-item><a href=/C++11/new-characger-type/>新字符类型</a><li class=nav-item><a href=/C++11/noexcept/>noexcept关键字</a><li class=nav-item><a href=/C++11/non-static-data-member-initializers/>非静态数据成员初始化</a><li class=nav-item><a href=/C++11/nullptr/>Nullptr</a><li class=nav-item><a href=/C++11/override-and-final/>override和final关键字</a><li class=nav-item><a href=/C++11/range-for-loop/>基于范围的for循环</a><li class=nav-item><a href=/C++11/raw-string-literals/>原始字面量字符串</a><li class=nav-item><a href=/C++11/ref-qualifiers/>扩展移动语义</a><li class=nav-item><a href=/C++11/right-angle-brackets/>右尖括号</a><li class=nav-item><a href=/C++11/rvalue-ref/>右值引用</a><li class=nav-item><a href=/C++11/static-assert/>静态断言</a><li class=nav-item><a href=/C++11/strongly-typed-enum/>强类型枚举</a><li class=nav-item><a href=/C++11/template-aliases/>模板别名</a><li class=nav-item><a href=/C++11/thread-local-storage/>线程本地存储</a><li class=nav-item><a href=/C++11/trailing-function-return-types/>过滤函数返回类型</a><li class=nav-item><a href=/C++11/type-traits/>类型萃取</a><li class=nav-item><a href=/C++11/unicode-string-literals/>Unicode字面量字符串</a><li class=nav-item><a href=/C++11/unrestricted-unions/>非受限联合体</a><li class=nav-item><a href=/C++11/user-defined-literals/>用户自定义字面量</a><li class=nav-item><a href=/C++11/variadic-templates/>可变参数模板</a></ul><li class="nav-item top-level"><a href=/C++14/binary-literals/>C++14</a><ul><li class=nav-item><a href=/C++14/binary-literals/>二进制字面量</a><li class=nav-item><a href=/C++14/clarifying-memory-allocation/>澄清内存分配</a><li class=nav-item><a href=/C++14/constexpr-for-array/>&lt;array>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-chrono/>&lt;chrono>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-complex/>&lt;complex>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-initializer_list-utility-and-tuple/>&lt;initializer_list>，&lt;utility>和&lt;tuple>的常量表达式</a><li class=nav-item><a href=/C++14/decltype(auto)-return-type-deduction-for-normal-functions/>普通函数返回值类型推导</a><li class=nav-item><a href=/C++14/deprecated-attribute/>废弃的属性</a><li class=nav-item><a href=/C++14/dual-range-std-equal-std-is_permutation-std-mismatch/>双范围的std::equal, std::is_permutation, std::mismatch</a><li class=nav-item><a href=/C++14/extended-constexpr/>扩展常量表达式</a><li class=nav-item><a href=/C++14/fixing-constexpr-member-function-without-const/>修复成员函数常量表达式不能带const修饰</a><li class=nav-item><a href=/C++14/generic-plymorphic-lambda/>Lambda表达式的泛型和多态</a><li class=nav-item><a href=/C++14/heterogeneous-associative-lookup/>关联容器异构比较查找算法</a><li class=nav-item><a href=/C++14/improved-std-integral_constant/>改进std::integral_constant</a><li class=nav-item><a href=/C++14/initialized-generalized-lambda-captures/>初始化和泛化lambda表达式捕获列表</a><li class=nav-item><a href=/C++14/member-initializers-and-aggregates/>成员初始化和聚合</a><li class=nav-item><a href=/C++14/null-forward-iterators/>Null前向迭代器</a><li class=nav-item><a href=/C++14/single-quote-as-digit-separator/>单引号作为数字分隔符</a><li class=nav-item><a href=/C++14/sized-deallocation/>释放指定大小的内存</a><li class=nav-item><a href=/C++14/std-exchange/>std::exchage</a><li class=nav-item><a href=/C++14/std-get_T/>std::get&lt;T>()</a><li class=nav-item><a href=/C++14/std-integer_squence/>std::integer_squence</a><li class=nav-item><a href=/C++14/std-quoted/>std::quoted</a><li class=nav-item><a href=/C++14/std-result_of-and-SFINAE/>std::result_of和SFINAE</a><li class=nav-item><a href=/C++14/std-shared_timed_mutex/>std::shared_timed_mutex</a><li class=nav-item><a href=/C++14/tweaked-wording-for-contextual-conversions/>调整上下文转换</a><li class=nav-item><a href=/C++14/user-defined-literals-for-chrono-and-string/>为chrono和string提供用户自定义字面量</a><li class=nav-item><a href=/C++14/variable-templates/>变量模板</a></ul><li class="nav-item top-level"><a href=/C++17/%5B%5Bfallthrough%5D%5D-attribute/>C++17</a><ul><li class=nav-item><a href=/C++17/%5B%5Bfallthrough%5D%5D-attribute/>[[fallthrough]]属性</a><li class=nav-item><a href=/C++17/%5B%5Bmaybe_unused%5D%5D-attribute/>[[maybe_unused]]属性</a><li class=nav-item><a href=/C++17/%5B%5Bnodiscard%5D%5D-attribute/>[[nodiscard]]属性</a><li class=nav-item><a href=/C++17/aggregate-initialization-of-class-with-base-classes/>聚合带基类的类的初始化</a><li class=nav-item><a href=/C++17/allow-constant-evaluation-for-all-non-type-template-arguments/>允许所有非类型模板参数进行参量计算</a><li class=nav-item><a href=/C++17/attributes-for-namespaces-and-enumerators/>名字空间和枚举的属性</a><li class=nav-item><a href=/C++17/constexpr-if-statements/>if语句常量表达式</a><li class=nav-item><a href=/C++17/constexpr-lambda-expressions/>Lambda常量表达式</a><li class=nav-item><a href=/C++17/differing-begin-and-end-types-in-range-based-for/>基于范围的for循环可以拥有不同类型的begin和end</a><li class=nav-item><a href=/C++17/direct-list-initialization-of-enumerations/>枚举直接列表初始化</a><li class=nav-item><a href=/C++17/dynamic-memory-allocation-for-over-aligned-data/>为过量对齐数据动态分配内存</a><li class=nav-item><a href=/C++17/elementary-string-convertions/>基础字符串转换</a><li class=nav-item><a href=/C++17/fold-expressions/>折叠表达式</a><li class=nav-item><a href=/C++17/guaranteed-copy-elision/>保证复制省略</a><li class=nav-item><a href=/C++17/hexadecimal-floating-point-literals/>16进制浮点字面量</a><li class=nav-item><a href=/C++17/ignore-unknown-attributes/>忽略未知属性</a><li class=nav-item><a href=/C++17/improving-std-pair-and-std-tuple/>改进std::pair和std::tuple</a><li class=nav-item><a href=/C++17/init-statements-for-if-and-switch/>if和switch的初始化语句</a><li class=nav-item><a href=/C++17/inline-variables/>Inline变量</a><li class=nav-item><a href=/C++17/lambda-capture-of-star-this/>Lambda表达式可以捕获*this</a><li class=nav-item><a href=/C++17/make-exception-specifications-part-of-the-type-system/>将异常规范作为类型系统的一部分</a><li class=nav-item><a href=/C++17/matching-of-template-template-arguments-excludes-compatible-templates/>匹配排除兼容模板后的模板模板参数</a><li class=nav-item><a href=/C++17/nested-namespace-definition/>嵌套名字空间定义</a><li class=nav-item><a href=/C++17/new-auto-rules-for-direct-list-initialization/>为直接列表初始化设置新的auto规则</a><li class=nav-item><a href=/C++17/new-specification-for-inheriting-constructors/>继承构造函数的新规范</a><li class=nav-item><a href=/C++17/non-type-template-parameters-with-auto-type/>用auto类型作为无类型的模板参数</a><li class=nav-item><a href=/C++17/pack-expansions-in-using-declarations/>在using声明中使用打包扩张(pack expansion)</a><li class=nav-item><a href=/C++17/remove-deprecated-exception-specifications-from-C++17/>删除C++17中废弃的异常规范</a><li class=nav-item><a href=/C++17/remove-deprecated-operator++(bool)/>删除废弃的operator++(bool)</a><li class=nav-item><a href=/C++17/remove-deprecated-use-of-the-register-keyword/>删除废弃的register关键字</a><li class=nav-item><a href=/C++17/removing-trigraphs/>删除三联符</a><li class=nav-item><a href=/C++17/splicing-maps-and-sets/>拼接map和set</a><li class=nav-item><a href=/C++17/standardization-of-parallelism-ts/>并行的技术规范标准化</a><li class=nav-item><a href=/C++17/static_assert-with-no-message/>无消息的静态断言</a><li class=nav-item><a href=/C++17/std-shared_mutex(untimed)/>std::shared_mutex（untimed）</a><li class=nav-item><a href=/C++17/std-string_view/>std::string_view</a><li class=nav-item><a href=/C++17/std-uncaught_exceptions/>std::uncaught_exceptions</a><li class=nav-item><a href=/C++17/stricter-expression-evaluation-order/>更严格的表达式估值顺序</a><li class=nav-item><a href=/C++17/structured-bindings/>结构化绑定</a><li class=nav-item><a href=/C++17/template-argument-deduction-for-class-template/>类模板的模板参数推导</a><li class=nav-item><a href=/C++17/typename-in-a-template-template-parameter/>模板模板参数中使用typename</a><li class=nav-item><a href=/C++17/u8-character-literals/>u8字符字面量</a><li class=nav-item><a href=/C++17/unary-fold-expressions-and-empty-parameter-pack/>一元折叠表达式和空参打包</a><li class=nav-item><a href=/C++17/using-attribute-namespaces-without-repetition/>不重复地使用带属性的名字空间</a></ul></ul><ul><li class="nav-item top-level"><a href=/changelog/>更新日志</a></ul></nav></header><section class=main><div class=page-header><h2>不那么新的modern C++简要学习笔记</h2><h3>Search</h3></div><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-3435940217424489 data-ad-slot=9166587836 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><article class=content><p><span id=search-process>Loading</span> results <span id=search-query-container style=display:none>for "<strong id=search-query></strong>"</span><ul id=search-results></ul><script>window.data={"c-11-alignas":{id:"c-11-alignas",title:"Alignas",category:"",url:" /C++11/alignas/",content:"编译器支持最低版本要求: GCC: 4.8 MSVC: 19.0 Clang: 3.0 提案: N2341 C++11引入了alignas关键字，它是一个对齐说明符，可以让程序员控制变量的对齐方式。 在C++中，编译器会对变量进行对齐，以便更好地利用CPU的缓存机制，提高程序的性能。对齐是指将数据存储在内存中的起始地址，使其能够被CPU高效地访问。 通常情况下，编译器会将变量按照CPU的缓存行大小进行对齐。例如，对于一个4字节的变量，在x86架构下，它会被对齐到4字节的整数倍，即4、8、12等。 但是，在某些情况下，程序员可能希望将变量以不同的方式进行对齐。这时，可以使用alignas关键字来指定对齐方式。 例如，假设我们定义了一个结构体： struct MyStruct { char c; double d; }; 这个结构体的大小应该是16字节（因为double通常是8字节），但是由于c的大小只有1字节，编译器会将它放在起始地址，这会导致结构体的大小为9字节。如果我们想让这个结构体按照16字节对齐，可以这样做： struct alignas(16) MyStruct { char c; double d; }; 这样，编译器会强制将这个结构体按照16字节对齐。 需要注意的是，alignas关键字只能用于变量、类型、typedef、模板类型参数和非静态数据成员。它不能用于函数、类或枚举。并且，alignas的参数必须是一个常量表达式。"},"c-11-alignof":{id:"c-11-alignof",title:"Alignof",category:"",url:" /C++11/alignof/",content:'编译器支持最低版本要求: GCC: 4.5 MSVC: 19.0 Clang: 2.9 提案: N2341 C++11引入了一个对齐相关的关键字——alignof，它是一个类型查询运算符，用于获取一个类型的对齐要求。 使用alignof关键字可以查询一个类型的对齐要求，语法如下： alignof(type) 其中，type可以是任何类型。例如，我们可以查询一个double类型的对齐要求： alignof(double) 在C++中，对齐要求是由编译器决定的，它通常取决于CPU架构和操作系统。例如，在x86架构下，通常使用4字节对齐。因此，上面的代码应该返回4。 需要注意的是，alignof返回的是一个常量表达式，它的值在编译时就已经确定了。这意味着，我们可以在编译时利用alignof来进行静态断言，以确保类型满足特定的对齐要求。例如： static_assert(alignof(double) == 8, "double must be 8-byte aligned"); 这个静态断言会在编译时检查double类型的对齐要求是否为8，如果不是，就会产生一个编译错误。 需要注意的是，alignof关键字不是一个类型或变量的属性，它只是用于查询类型的对齐要求。因此，它不能用于变量或表达式。例如，下面的代码是不合法的： int i; alignas(4) int j; std::cout &lt;&lt; alignof(i) &lt;&lt; std::endl; Error! std::cout &lt;&lt; alignof(j) &lt;&lt; std::endl; OK'},"c-11-atomic-operations":{id:"c-11-atomic-operations",title:"原子操作",category:"",url:" /C++11/atomic-operations/",content:"编译器支持最低版本要求: GCC: 4.4 MSVC: 17.0 Clang: 3.1 提案: N2427"},"c-11-attributes":{id:"c-11-attributes",title:"属性",category:"",url:" /C++11/attributes/",content:"编译器支持最低版本要求: GCC: 4.8 MSVC: 19.0 Clang: 3.3 提案: N2761"},"c-11-auto":{id:"c-11-auto",title:"自动类型推导",category:"",url:" /C++11/auto/",content:"编译器支持最低版本要求: GCC: 4.4(v1.0) MSVC: 16.0(v0.9) Clang: Yes 提案: N1984(v1.0) 自动类型推导是降低编码负担的一种手段，在其他编程语言比如Go中也有类似的功能。C++11修改了关键字auto原有的作用，使其为自动类型推导所用。在C++11之前，template就已经具有类型推导能力，而C++11中增加的auto通常情况下就是使用template的类型推导方式： int main(int argc, char *argv[]) { auto x = 17; x = int auto&amp; y = x; y = int&amp; const auto&amp; i = x; i = const int&amp; auto z = y; z = int const auto f = y; f = const int auto&amp; m = i; m = const int&amp; auto&amp;&amp; t = i; t = int&amp; auto&amp;&amp; t1 = 10; t1 = int&amp;&amp; return 0; } int main(int argc, char *argv[]) { int A[3] = {1, 2, 3}; auto a = A; a = int * auto&amp; a1 = A; a1 = int (&amp;)[3] return 0; } 还有了新式的函数声明形式： auto get_fun(int arg) -&gt; double (*)(double) same as: double (*get_fun(int))(double) { switch (arg) { case 1: return std::fabs; case 2: return std::sin; default: return std::cos; } } auto代替了声明变量时的强制类型信息如int，int&amp;，const int&amp;，int&amp;&amp;等等，但是在使用auto时： 必须初始化变量，当然好的编码实践即使不用auto也会要求声明变量时立即初始化 函数返回值不能是auto（仅C++11而言，C++14中已经修改） 函数的形参类型不能是auto，即使指定了默认参数也不行（仅C++11而言，C++14中lambda表达式部分已经修改） auto不能声明为模板的参数（仅C++11而言？） 非静态成员变量不能是auto的，即使指定了初始值也不行 不能声明auto数组 另外，由于C++11新增了初始化列表功能，使用auto自动推导出来的类型可能会有出乎意料的情况： int main(int argc, char *argv[]) { int a0 = (1); a0 = int auto a1 = (1); a1 = int int a2 = {1}; a0 = int auto a3 = {1}; a3 = std::initializer_list&lt;int&gt; return 0; } a1如愿得到int类型，而a3却跟a2是不同的类型，因为初始化列表拥有特有的类型std::initializer_list&lt;int&gt;。 一般而言，在以下场合使用auto比较合适： 类型名比较长，比如std::vector&lt;std::string&gt;::iterator， std::shared_ptr&lt;std::vector&gt;等等诸如此类的要声明变量可以使用auto 类型名比较难书写，比如临时定义一个lambda表达式，又要把它保存到一个变量中以便之后调用，就可以用auto： auto f = [&amp;](int n)-&gt;int { return n+1; }; auto i = f(10); Scott Meyers在《Effective Modern C++》中提议优先使用auto，这也许是一种趋势。 相关链接 decltype Lambda表达式 初始化列表 普通函数返回值类型推导 Lambda表达式的泛型和多态 获取变量精确类型的示例（GCC，Clang可用）"},"c-11-c99-preprocessor":{id:"c-11-c99-preprocessor",title:"C99兼容预处理器",category:"",url:" /C++11/c99-preprocessor/",content:'编译器支持最低版本要求: GCC: 4.3 MSVC: 19.0 Clang: Yes 提案: N1653 预处理器的改进包括几个方面。 扩展整型数据类型 C++11标准只定义了5种有符号整型： signed char short int int long int long long int，此类型为C++11中新引入并标准化 同时每种有符号整型分别对应一种无符号整型，且对应的两种类型具有相同的存储空间大小。 为了满足实际编程中更多的需求，C++11标准允许编译器增加自有的扩展整型数据类型（即使不允许，人家编译器厂商这么多年来也已经这么干了），标准对扩展的类型的名称没有规定，但要求扩展的有符号整型和对应的无符号整型具有相同的存储空间大小。 另外，为了能可预期地应对隐式类型转换（类型提升），一般有如下原则的认知： 长度越大的整型等级越高 长度相同的情况下，标准整型等级高于扩展类型 相同大小的有符号类型和无符号类型的等级相同 隐式转换时一般按低等级向高等级类型转换，有符号向无符号类型转换 混合不同类型字符串字面量的拼接 C++11一共有5种字符串字面量： const char * sz = "hello"; 窄字符串 const wchar_t * wsz = L"hello"; 传统宽字符串 const char * u8sz = u8"hello"; C++11新增UTF-8 编码字符串 const char16_t * u16sz = u"hello"; C++11新增UTF-16 编码字符串 const char32_t * u32sz = U"hello"; C++11新增UTF-32 编码字符串 除了第一种是窄字符串外，另外几种都算宽字符串，后三种是对第二种的扩展。 在C++中两个连续的同类型字符串字面量会自动拼接成一个： const char * sz = "hello" " world"; 相当于赋值"hello world"; 但是在C++11之前，宽窄不同类型字符串字面量放在一起，则是未定义行为： const wchar_t * sz = "hello" L" world"; C++98 03未定义行为，C++11则以宽字符串字面量拼接 上式在C++11中则以宽字符串字面量拼接，相当于赋值L"hello world"。C++11中多个字符串字面量连续定义的，不带前缀的字符串字面量全部转为带前缀的字符串字面量，比如： const char * sz1 = "hello" u" world"; 相当于赋值u"hello world" const char * sz2 = u"hello" " world"; 相当于赋值u"hello world" 不同类型字符串字面量的拼接也有些限制： UTF-8和宽字符串字面量同时声明会有冲突 其他带前缀的多个字符串字面量连接定义行为未标准化，由编译器自行定义实现 诊断#include包含的头文件的名字 是个奇怪的特性，如果#include语句后面包含的头文件（路径）第一个字符是个数字，则编译器会警告，比如： inc.cpp #include "0x header.h" 这个代码编译时大概会输出如下的警告： "inc.cpp", line 1.10: 1540-0893 (W) The header file name "0x header.h" in #include directive shall not start with a digit. 好像没什么用。 增加#line预处理指令的上限 #line可以重新设置当前源代码文件的行号和文件名（用于编译器warning，error之类消息输出定位）。在C++11之前，#line可设置的行号最大值是32767，在C++11中调整为2147483647。 诊断对象类的宏定义 _Pragma操作符 C++标准中#pragma预处理器指令可以用来向编译器传递一些语言标准以外的信息，比如： #pragma once 该文件只被编译一遍，一般用于头文件中 #pragma comment(lib, "user32") 本文件代码依赖user32.lib，链接时会自动寻找并链接 #pragma warning(disable: 4996) 禁止上报编号为4996的编译器警告 C++11增加了_Pragma操作符，提供了跟#pragma几乎相同的功能，格式为：_Pragma(字符串字面量)。所以上面的#pragma示例可以用_Pragma改写为： _Pragma("once"); _Pragma("comment(lib, \\"user32\\")"); _Pragma("warning(disable: 4996)"); 用_Pragma而不用#pragma的好处是_Pragma是个操作符，所以可以用于宏定义中，而#pragma不行： #define COMPILED_ONCE _Pragma("once") 变长参数宏定义 C++11增加了__VA_ARGS__用于处理变长参数的宏定义： #define PR(...) printf(__VA_ARGS__) 看来唯一的作用就是把宏定义的变长参数转为函数的变长参数。 预定义宏 C++11新增4个与C99兼容的预定义宏： 宏名称 功能 __STDC__ 当前编译器是否和C标准实现一致，是否定义以及定义成什么值由编译器决定。 __STDC_VERSION__ 当前编译器支持的C标准的版本，比如1999mmL，是否定义以及定义成什么值由编译器决定。 __STDC_ISO_10646__ 当前编译器是否符合某个版本的ISO IEC 10646标准，比如199712L，是否定义以及定义成什么值由编译器决定。 __STDC_HOSTED__ 当前编译器环境是否带有完整的标准C库，非0即1。 除此之外，C++11例行更新了__cplusplus的值为201103L，因此可以根据这个宏来判断当前编译环境是否支持C++11: #if __cplusplus &lt; 201103L #error "C++11 is needed" #endif 另外，C++11标准化了预定义标识符__func__，尽管有些编译器老就支持了。__func__代表所在函数的名字字符串，因此如果用在函数未定义的位置（比如在函数声明的参数列表处作为参数缺少值）是编译不通过的。 常见编译器（MSVC除外，求告知！）缺省预定义宏可以通过命令行查看： 编译器 查看C++预定义宏命令(注意添加相对应的C++标准版命令行参数) Clang LLVM clang++ -dM -E -x c++ dev null GCC g++ -dM -E -x c++ dev null HP C aC++ aCC -dM -E -x c++ dev null IBM XL C C++ xlc++ -qshowmacros -E dev null Intel C++ icpc -dM -E -x c++ dev null Oracle Solaris Studio CC -xdumpmacros -E dev null ​'},"c-11-constexpr":{id:"c-11-constexpr",title:"常量表达式",category:"",url:" /C++11/constexpr/",content:"编译器支持最低版本要求: GCC: 4.6 MSVC: 19.0 Clang: 3.1 提案: N2235 背景 在C++11之前，程序中的常量表达式主要依赖于宏定义和const变量。但这些方式都存在一些局限性： 宏定义不具备类型安全性，且容易导致代码可维护性降低 const变量虽然不可修改，但并不保证在编译期可计算 一些需要编译期常量的场景（如数组大小、模板参数等）无法使用更灵活的表达式 为了解决这些问题，C++11引入了constexpr关键字，用于声明可以在编译期计算的常量表达式。 基本用法 constexpr变量 constexpr变量必须用常量表达式初始化： constexpr int size = 42; OK constexpr int double_size = size 2; OK constexpr int random = rand(); 错误：rand()不是常量表达式 constexpr函数 constexpr函数在编译期可计算，但也可以在运行时使用： constexpr int square(int x) { return x x; } 编译期计算 constexpr int sq_5 = square(5); sq_5 = 25，编译期确定 运行时计算 int some_value = get_value(); int sq_val = square(some_value); 运行时计算 使用场景 1. 数组维度声明 constexpr int get_array_size() { return 42; } int array[get_array_size()]; OK，编译期可确定大小 2. 模板参数 template&lt;int N&gt; struct Array { int data[N]; }; constexpr int size = 10; Array&lt;square(size)&gt; arr; OK，square(size)在编译期计算 3. 编译期计算提升性能 constexpr int fibonacci(int n) { return (n &lt;= 1) ? n : fibonacci(n-1) + fibonacci(n-2); } 编译期就计算出结果 constexpr int fib_10 = fibonacci(10); 限制条件 C++11中的constexpr函数有较多限制： 函数体只能包含一条return语句 只能调用其他constexpr函数 不能包含循环或分支语句 不能有副作用（如修改静态或全局变量） 注意：这些限制在C++14中得到了很大放松。 最佳实践 当需要编译期常量时，优先使用constexpr而不是宏定义 设计编译期可计算的函数时，尽量使用constexpr声明 constexpr函数应保持简单，避免复杂的逻辑 记住constexpr函数可以在运行时使用，这提供了很好的灵活性 与其他特性的对比 constexpr vs const 计算时机 const：仅表示运行时常量，不可修改 constexpr：表示编译期常量，编译器会在编译期计算其值 使用场景 const示例 const int val1 = 42; OK const int val2 = get_value(); OK，运行时初始化 int arr1[val1]; 错误：数组大小需要编译期常量 int arr2[val2]; 错误：数组大小需要编译期常量 constexpr示例 constexpr int val3 = 42; OK constexpr int val4 = get_value(); 错误：需要编译期常量表达式 int arr3[val3]; OK，val3是编译期常量 函数声明 const成员函数：表示不会修改对象状态 class MyClass { int value; public: int getValue() const { return value; } 运行时执行 }; constexpr函数：可在编译期执行 constexpr int square(int x) { return x x; } 编译期执行 主要区别总结： const主要用于： 声明运行时不可修改的变量 声明不修改对象状态的成员函数 声明指向常量的指针或引用 constexpr主要用于： 声明编译期可计算的常量 声明编译期可执行的函数 用在需要编译期常量的场景（如数组大小、模板参数等） constexpr vs #define 类型安全性 #define MAX_SIZE 100 无类型检查 constexpr int MaxSize = 100; 有类型检查 void foo(short s) { #define SQUARE(x) ((x) (x)) short s1 = SQUARE(s); 可能溢出，无警告 constexpr auto square = { return x x; }; short s2 = square(s); 编译器会进行类型检查 } 作用域 #define：无作用域概念，全局生效 constexpr：遵循正常的作用域规则 调试友好性 #define：预处理阶段处理，调试时看不到原始值 constexpr：是正常的变量和函数，调试时可以看到具体值 主要优势对比： #define： 简单的文本替换 可用于条件编译 预处理阶段处理 constexpr： 类型安全 支持作用域 可以使用复杂表达式 调试友好 支持函数和类成员 使用建议 优先级顺序： 需要编译期常量时：首选constexpr 仅需要运行时常量时：使用const 仅在确实需要预处理器功能时：使用#define 场景选择： 模板参数：使用constexpr 数组大小：使用constexpr 运行时只读变量：使用const 条件编译：使用#define 总结 constexpr是C++11引入的重要特性，它为编译期计算提供了类型安全和更好的可维护性。通过合理使用constexpr，我们可以： 在编译期进行更多计算，提升运行时性能 实现更灵活的编译期常量表达式 保证类型安全性 提高代码的可维护性 随着C++14、C++17的发展，constexpr的功能更加强大，使用场景也更加广泛。"},"c-11-decltype":{id:"c-11-decltype",title:"decltype",category:"",url:" /C++11/decltype/",content:"编译器支持最低版本要求: GCC: 4.3(v1.0), 4.8.1(v1.1) MSVC: 16.0(v1.1) Clang: 2.9 提案: v1.0 - N2343 v1.1 - N3276 大概是为了更好地配合auto进行自动类型推导，C++11引入了decltype操作符，用于检查某个实体（比如变量）的声明类型或表达式的类型及值分类，所以有以下用法： decltype(entity) decltype(expression) 括号是必不可少的，但也是需要慎重使用的，因为表达式如果被括号括着，会被当做通常的左值表达式，所以decltype(x)和decltype((x))通常会得到不同的结果： int i; decltype(i) a; a: int decltype((i)) b; b: int &amp;，无法编译通过 一般说来，C++11按以下规则来返回decltype(x)的类型： 如果x是一个没有带括号的标记符表达式（id-expression）或者类成员访问表达式，那么decltype(x)就是x所命名的实体的类型。如果x是一个被重载的函数，则会导致编译错误。 否则，假设x的类型是T，如果x是一个将亡值（xvalue），那么decltype(x)结果为T&amp;&amp;。 否则，假设x的类型是T，如果x是一个左值（lvalue），那么decltype(x)结果为T&amp;。 否则，假设x的类型是T，x是一个纯右值（prvalue），那么decltype(x)结果为T。 左值、右值（将亡值、纯右值） C++11之前，程序内的值分为左值（lvalue）和右值（rvalue）两种： 可以取地址的，有名字的就是左值 不能取地址的，没有名字的就是右值 比如a = b + c中，a就是左值，b + c就是右值，粗略地可以通过看它是在赋值表达式中赋值符的左边还是右边。 C++11中，右值（rvalue）又细分为将亡值（xvalue，eXpiring value）和纯右值（prvalue，pure rvalue）： 纯右值就是C++11之前标准中的右值 将亡值是C++11新增的跟右值引用相关的表达式，比如返回右值引用T&amp;&amp;的函数返回值，std::move的返回值，转换为T&amp;&amp;的类型转换函数的返回值 推导函数返回值类型 配合auto和decltype，可以自动推导函数返回值类型： template&lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u) the return type is the type of operator+(T, U) { return t + u; } 相关链接 decltype示例代码"},"c-11-defaulted-and-deleted-functions":{id:"c-11-defaulted-and-deleted-functions",title:"缺省函数和可删除函数",category:"",url:" /C++11/defaulted-and-deleted-functions/",content:"编译器支持最低版本要求: GCC: 4.4 MSVC: 18.0 Clang: 3.0 提案: N2346"},"c-11-delegating-constructors":{id:"c-11-delegating-constructors",title:"委托构造函数",category:"",url:" /C++11/delegating-constructors/",content:"编译器支持最低版本要求: GCC: 4.7 MSVC: 18.0 Clang: 3.0 提案: N1986"},"c-11-dynamic-initialization-and-destruction-with-concurrency":{id:"c-11-dynamic-initialization-and-destruction-with-concurrency",title:"动态初始化和并发析构（魔法静态）",category:"",url:" /C++11/dynamic-initialization-and-destruction-with-concurrency/",content:"编译器支持最低版本要求: GCC: 4.3 MSVC: 19.0 Clang: 2.9 提案: N2660"},"c-11-dynamic-pointer-safety":{id:"c-11-dynamic-pointer-safety",title:"动态指针安全（垃圾回收接口）",category:"",url:" /C++11/dynamic-pointer-safety/",content:"提案: N2670 目前主流编译器（包括GCC、MSVC、Clang、Intel C++等）均未实现。"},"c-11-explicit-conversion-operators":{id:"c-11-explicit-conversion-operators",title:"显式转换操作符",category:"",url:" /C++11/explicit-conversion-operators/",content:"编译器支持最低版本要求: GCC: 4.5 MSVC: 18.0 Clang: 3.0 提案: N2437"},"c-11-extended-friend-declarations":{id:"c-11-extended-friend-declarations",title:"扩展的friend声明",category:"",url:" /C++11/extended-friend-declarations/",content:"编译器支持最低版本要求: GCC: 4.7 MSVC: 16.0 Clang: 2.9 提案: N1791"},"c-11-extern-template":{id:"c-11-extern-template",title:"外部模板",category:"",url:" /C++11/extern-template/",content:"编译器支持最低版本要求: GCC: 3.3 MSVC: 12.0 Clang: Yes 提案: N1987 C++11引入了一个新特性——extern template。这个特性可以用于显式实例化一个模板，然后在另一个编译单元中使用它，以避免在每个编译单元中都生成一个新的实例。 在C++中，模板通常在头文件中定义。当头文件被包含到多个编译单元中时，每个编译单元都会生成一个新的模板实例。这会导致编译时间增加，并且可能会导致代码大小变大。 extern template可以避免这个问题。它的语法形式为： extern template class template-name&lt;template-arguments&gt;; 这里，template-name是模板的名称，template-arguments是模板参数。通过使用extern template，我们可以显式地实例化一个模板，并告诉编译器在另一个编译单元中使用它。例如： 在A.cpp中显式实例化一个模板 template class std::vector&lt;int&gt;; 在B.cpp中使用该模板 void foo() { std::vector&lt;int&gt; v; 不会在B.cpp中生成新的实例 ... } 这里，在A.cpp中显式实例化了一个std::vector&lt;int&gt;模板，并告诉编译器在另一个编译单元中使用它。在B.cpp中使用该模板时，不会生成新的实例，而是使用在A.cpp中已经实例化的版本。 需要注意的是，使用extern template并不会完全替代模板的头文件定义。如果一个模板被多个编译单元使用，并且它的实现依赖于某些特定的编译器选项，那么仍然需要在头文件中定义模板。此外，extern template只能用于类模板，不能用于函数模板。"},"c-11-forward-enum-declarations":{id:"c-11-forward-enum-declarations",title:"前向声明枚举类型",category:"",url:" /C++11/forward-enum-declarations/",content:"编译器支持最低版本要求: GCC: 4.6 MSVC: 3.1 Clang: 17.0 提案: N2764 在C++中，可以使用枚举类型（enum）定义一组常量。而在某些情况下，我们需要使用前向声明（forward declaration）来提前声明枚举类型，以便在后续代码中使用该枚举类型，这就是forward enum declarations。 在C++11之前，如果需要前向声明一个枚举类型，需要使用如下的语法： enum Color; 前向声明 后续代码中定义枚举类型 enum Color { RED, GREEN, BLUE }; 上述代码中，我们先使用enum Color来提前声明了一个枚举类型Color，然后在后续的代码中使用enum Color {…}来定义这个枚举类型。 然而，这种语法并不太直观，并且容易导致一些错误。在C++11中，引入了新的语法，可以更方便地进行前向声明枚举类型： enum class Color : int; 前向声明 后续代码中定义枚举类型 enum class Color : int { RED, GREEN, BLUE }; 上述代码中，我们先使用enum class Color : int来提前声明了一个枚举类型Color，其中int为枚举类型的底层类型。然后在后续的代码中使用enum class Color : int {…}来定义这个枚举类型。 使用新的语法，我们可以更清晰地进行枚举类型的前向声明，并且避免了使用旧语法时可能出现的错误。此外，新的语法还可以更好地支持C++11的类型安全枚举（enum class）特性。 需要注意的是，在使用前向声明时，如果需要在其他代码中使用这个枚举类型，仍然需要保证该枚举类型的底层类型是已知的。因此，在使用前向声明时，需要根据实际情况选择合适的底层类型，并保证后续代码中的枚举类型与前向声明的底层类型相同。"},"c-11-inheriting-constructors":{id:"c-11-inheriting-constructors",title:"继承构造函数",category:"",url:" /C++11/inheriting-constructors/",content:"编译器支持最低版本要求: GCC: 4.8 MSVC: 19.0 Clang: 3.3 提案: N2540 C++11引入了一项新特性，称为“继承构造函数”（Inheriting Constructors），允许派生类继承基类的构造函数，从而可以简化派生类的构造函数实现。 当派生类没有自己的构造函数时，可以使用继承构造函数来继承基类的构造函数。例如，考虑下面这个示例： class Base { public: Base(int x) : m_x(x) {} private: int m_x; }; class Derived : public Base { public: using Base::Base; }; 这里，派生类Derived继承了基类Base的构造函数。在Derived的定义中，使用了using声明来继承基类的构造函数。这意味着，在使用Derived的构造函数时，可以像使用Base的构造函数一样，传递一个int类型的参数。 例如，我们可以这样创建一个Derived对象： Derived d(42); 这里，调用的是Base的构造函数，传递了一个int类型的参数42。由于Derived没有自己的构造函数，因此编译器会自动合成一个默认构造函数。 需要注意的是，继承构造函数只能继承基类的构造函数，不能继承其它成员函数。并且，如果基类的构造函数有重载版本，需要使用using声明来显式指定继承哪一个版本的构造函数。 例如，如果Base有一个默认构造函数和一个带两个参数的构造函数： class Base { public: Base() : m_x(0) {} Base(int x) : m_x(x) {} private: int m_x; }; 那么，在Derived中，需要使用using声明来指定继承哪一个版本的构造函数。例如，我们可以这样来继承带一个int类型参数的构造函数： class Derived : public Base { public: using Base::Base; }; 这样，Derived就继承了Base的带一个int类型参数的构造函数，而不是默认构造函数。"},"c-11-initializer-lists":{id:"c-11-initializer-lists",title:"初始化列表",category:"",url:" /C++11/initializer-lists/",content:"编译器支持最低版本要求: GCC: 4.4 MSVC: 18.0 Clang: 3.1 提案: N2672"},"c-11-inline-namespace":{id:"c-11-inline-namespace",title:"内联名字空间",category:"",url:" /C++11/inline-namespace/",content:"编译器支持最低版本要求: GCC: 4.4 MSVC: 19.0 Clang: 2.9 提案: N2535"},"c-11-lambda":{id:"c-11-lambda",title:"Lambda表达式",category:"",url:" /C++11/lambda/",content:"编译器支持最低版本要求: GCC: 4.5(v1.1) MSVC: 16.0 Clang: 3.1 提案: v0.9 - N2550 v1.0 - N2658 v1.1 - N2927 Lambda表达式就是匿名函数，在C++11之前Boost凭借C++语言强大的template和预处理宏，以及库作者强悍的奇技淫巧实现了Boost.lambda和更高级用法Boost.phoenix，但没有语言层面的支持，完全用库实现不但稍显累赘，而且代码观感不佳。C++11在语言层面实现了lambda，语法定义如下： [capture](parameters)mutable -&gt; return-value { statement } [capture]：捕捉列表，可以捕捉上下文中的变量以供lambda表达式使用。 (parameters)：参数列表，同普通函数相同的参数列表定义，如果没有参数，可以留空括号()，甚至连空括号都省略。在C++11中lambda参数类型不能自动推导，即不能为auto，在C++14中已经支持。 mutable：默认情况下lambda表达式是一个const函数，但可以显式指定mutable取消其常量性，这时不能省略空参数列表的空括号()。 -&gt; return-value：返回类型，如果没有返回类型（即void），可以全部省略。如果返回类型明确，也可以省略，让编译器进行自动类型推导。 { statement }：函数体，跟普通函数相同的用法。 所以一个最简单的lambda表达式是这样的： []{} 尽管它什么事都没干，也没什么作用，但确实是一个合法的lambda表达式。 捕捉列表可以有0个，或1个，或多个捕捉项，以逗号分隔，可以有以下几种形式： [var]，表示值传递方式捕捉变量var。 [&amp;var]，表示引用传递方式捕捉变量var。 [=]，表示值传递方式捕捉所有父作用域的变量。 [&amp;]，表示引用传递方式捕捉所有父作用域的变量。 [this]，表示捕捉当前this指针，但不能捕捉*this，但在C++17中已经可以捕捉。this也包括在[=]和[&amp;]中。 然后可以多个捕捉项组合： [=, &amp;a, &amp;b] [&amp;, a, b] 但是多个捕捉项不能重复： [a, a] [=, a] [&amp;, &amp;a] 捕捉列表的不同，效果也会不同： 按值传递的捕捉项在lambda表达式被定义时就已经决定。 按引用传递的捕捉项在lambda表达式被调用时决定。 按值传递的捕捉变量不能被lambda表达式内修改，按引用传递的可以。 从代码生成角度看，如果是内建数据类型（int，short，long之类的）如果以引用传递方式会比以值传递方式多一条获取变量地址的指令。 Lambda表达式在功能上跟仿函数（functor，也称函数对象，function object）非常相似：可以保存外部变量的状态，可以传入参数，可以被调用。编译器在实现lambda表达式时也采用了与仿函数相似的方法。 每个lambda表达式都有自己特有的类型，也就是说不能仅仅因为捕捉列表、参数列表、返回值类型相同而把一个lambda表达式赋给另一个保存着lambda表达式的变量，却可以把一个保存了lambda表达式的变量赋给另一个变量： auto f = [](int n)-&gt;int { return n;}; decltype(f) f2 = f; 正确 decltype(f) f3 = [](int n)-&gt;int { return n;}; 编译错误 Lambda表达式在C++中最典型的应用场景是作为被回调体，比如STL诸多算法需要提供谓词（predicate），简短的lambda比函数指针和仿函数都要更适合承担这份工作： 有机会被内联优化，函数指针不行。 就地定义、就地使用，短小、分散的仿函数破坏程序整体结构。 但是lambda表达式并不能完全取代仿函数： 函数体较大时，使用仿函数更能理清程序结构。 捕捉变量范围有限，仅在父作用域范围，尽管有的编译器（GCC可以捕捉到全局变量等）自行扩展了范围，但并不合标准定义。 相关链接 Lambda表达式可以捕获*this Lambda表达式的泛型和多态"},"c-11-local-and-unnamed-types-as-template-parameters":{id:"c-11-local-and-unnamed-types-as-template-parameters",title:"本地和匿名类型作为模板参数",category:"",url:" /C++11/local-and-unnamed-types-as-template-parameters/",content:"编译器支持最低版本要求: GCC: 4.5 MSVC: 16.0 Clang: 2.9 提案: N2657"},"c-11-long-long":{id:"c-11-long-long",title:"long long类型",category:"",url:" /C++11/long-long/",content:"编译器支持最低版本要求: GCC: Yes MSVC: Yes Clang: Yes 提案: N1811 C++11增加了long long和unsigned long long类型，其实在这之前有些编译器实现和一些第三方库也都提供了类似的类型。在C++11中long long类型在不同平台具有不同的长度，但至少是64位（8字节）。在写常数字面量时，可以使用LL后缀（或是ll）标识一个long long类型的字面量，相对地，用ULL（或ull， Ull， uLL）标识一个unsigned long long类型字面量，比如： long long lli = -1000000000000000LL; long long int lli2 = -1000000000000000LL; unsigned long long ulli = -1000000000000000ULL; unsigned long long int ulli2 = -1000000000000000ULL; C++11中有一些与long long等价的类型定义，比如long long int，signed long long和signed long long int。相对的，unsigned long long与unsigned long long int也是等价的。 在&lt;climits&gt;或&lt;limits.h&gt;中定义了LLONG_MAX， LLONG_MIN和ULLONG_MAX三个宏，分别代表在该编译器支持的平台上long long的最大值和最小值以及unsigned long long的最大值。 在用标准库函数printf进行格式化输出时，则分别使用%lld和%llu来标识long long和unsigned long long类型的变量。"},"c-11-money-time-hexfloat-io-manipulators":{id:"c-11-money-time-hexfloat-io-manipulators",title:"货币、时间、16进制浮点I/O操作",category:"",url:" /C++11/money-time-hexfloat-IO-manipulators/",content:"编译器支持最低版本要求: GCC: 5.1 MSVC: 19.0 Clang: 3.8 提案: Time - N2071 Money - N2072"},"c-11-new-characger-type":{id:"c-11-new-characger-type",title:"新字符类型",category:"",url:" /C++11/new-characger-type/",content:"编译器支持最低版本要求: GCC: 4.4 MSVC: 19.0 Clang: 2.9 提案: N2249"},"c-11-noexcept":{id:"c-11-noexcept",title:"noexcept关键字",category:"",url:" /C++11/noexcept/",content:"编译器支持最低版本要求: GCC: 4.6 MSVC: 19.0 Clang: 3.0 提案: N3050 C++11引入了一个新的异常说明符关键字——noexcept。它可以用于声明一个函数不会抛出任何异常，这对于一些性能敏感的代码非常有用。 在函数声明中使用noexcept关键字，可以显式地指定该函数不会抛出异常。例如： void foo() noexcept { ... } 这里，函数foo声明为noexcept，表示它不会抛出任何异常。在函数体中，我们可以放心地使用一些不安全的操作，比如使用裸指针或者直接访问硬件资源等。 需要注意的是，noexcept并不能保证函数不会抛出异常。如果函数在运行时仍然抛出了异常，那么程序会调用std::terminate()函数来终止程序的执行。 noexcept关键字也可以用于表达式、函数指针和模板参数。例如： void bar() { int* p = new int[10](); 分配10个int并初始化为0 ... delete[] p noexcept; 在delete[]操作中使用noexcept } 这里，在delete[]操作中使用noexcept关键字，表示如果分配内存时出现了异常，不会抛出异常而是直接调用std::terminate()。 需要注意的是，noexcept并不会影响函数的调用方式。也就是说，即使函数声明为noexcept，它也可以被普通的方式调用，而不是需要使用std::noexcept()进行调用。然而，在某些情况下，使用noexcept关键字可以帮助编译器进行优化，从而提高程序的性能。"},"c-11-non-static-data-member-initializers":{id:"c-11-non-static-data-member-initializers",title:"非静态数据成员初始化",category:"",url:" /C++11/non-static-data-member-initializers/",content:"编译器支持最低版本要求: GCC: 4.7 MSVC: 18.0 Clang: 3.0 提案: N2756"},"c-11-nullptr":{id:"c-11-nullptr",title:"Nullptr",category:"",url:" /C++11/nullptr/",content:"编译器支持最低版本要求: GCC: 4.6 MSVC: 16.0 Clang: 2.9 提案: N2431"},"c-11-override-and-final":{id:"c-11-override-and-final",title:"override和final关键字",category:"",url:" /C++11/override-and-final/",content:"编译器支持最低版本要求: GCC: 4.7 MSVC: 17.0 Clang: 2.9 提案: v0.8 - N2928 v0.9 - N3206 v1.0 - N3272"},"c-11-range-for-loop":{id:"c-11-range-for-loop",title:"基于范围的for循环",category:"",url:" /C++11/range-for-loop/",content:'编译器支持最低版本要求: GCC: 4.6 MSVC: 17.0 Clang: 3.0 提案: N2930 遍历容器是种广泛的需求，在C++11之前，有些库提供了遍历容器内所有元素的封装方法，比如Boost中的BOOST_FOREACH，Qt中的foreach关键字等等，甚至C++自己也提供了一个std::for_each算法。 C++11提供了基于范围的for循环： std::vector&lt;int&gt; coll = { 1, 2, 3}; for( int i : coll ) { std::cout &lt;&lt; i &lt;&lt; std::endl; } 以上代码以值拷贝方式访问到容器coll中的每个元素，这里可以使用auto来自动推导容器内元素的类型： std::vector&lt;int&gt; coll = { 1, 2, 3}; for( auto i : coll ) { std::cout &lt;&lt; i &lt;&lt; std::endl; } 如果需要修改容器内元素的内容，则需要声明引用类型int&amp; i或auto&amp; i。所以当容器内元素类型是复杂数据类型时，为运行效率考虑计，一般推荐引用或常量引用方式访问： std::vector&lt;std::string&gt; coll = { "element1", "element2", "element3"}; for (const auto&amp; s : coll) { std::cout &lt;&lt; s &lt;&lt; std::endl; } std::map是按std::pair迭代的，所以要这样遍历std::map： std::map&lt;std::string, std::string&gt; mm; for ( const auto&amp; m : mm ) { std::cout &lt;&lt; m.first &lt;&lt; " &lt; " &lt;&lt; m.second &lt;&lt; "&gt;" &lt;&lt; std::endl; } 一般而言，如下一组基于范围的for循环： for ( for-range-declaration : expression ) statement 等价于如下一组老式的for循环： { auto &amp;&amp; __range = ( expression ); for (auto __begin = begin-expr, __end = end-expr; __begin != __end; ++__begin ) { for-range-declaration = *__begin; statement } } 其中__range， __begin和__end仅用于说明，__RangeT是expression的类型，begin-expr和end-expr则依据以下规则决定： 如果__RangeT是数组类型，则begin-expr和end-expr分别等于__range和__range + __bound，相应的__bound是数组边界。因此如此__RangeT是不知大小的数组，或者不完整类型（有声明没定义）的数组，那么程序就不合法。 如果__RangeT类型拥有begin()和end()成员函数，则begin-expr和end-expr分别等于__range.begin()和__range.end()。 否则，begin-expr和end-expr分别等于begin(__range)和end(__range)，使用参数依赖查找算法进行查找，其实基本上就是std::begin()和std::end()。 __begin和__end具有相同的类型，在C++17中放宽了这个限制。 目前C++标准库中所有容器，std::string和数组都能用这种基于范围的for循环遍历，如果想要让自己的数据结构也支持这种语法，需要满足以下要求： 能对此自定义数据结构类型调用begin和end方法，无论是成员函数或者独立函数都可以，要能返回迭代器类型。 返回的迭代器类型必须支持operator*方法，operator!=方法和前缀形式的operator++方法，同样无论是成员函数或独立函数都可以。 相关链接 C++17 基于范围的for循环可以拥有不同类型的begin和end'},"c-11-raw-string-literals":{id:"c-11-raw-string-literals",title:"原始字面量字符串",category:"",url:" /C++11/raw-string-literals/",content:"编译器支持最低版本要求: GCC: 4.5 MSVC: 18.0 Clang: Yes 提案: N2442"},"c-11-ref-qualifiers":{id:"c-11-ref-qualifiers",title:"扩展移动语义",category:"",url:" /C++11/ref-qualifiers/",content:"编译器支持最低版本要求: GCC: 4.8.1 MSVC: 19.0 Clang: 2.9 提案: N2439"},"c-11-right-angle-brackets":{id:"c-11-right-angle-brackets",title:"右尖括号",category:"",url:" /C++11/right-angle-brackets/",content:"编译器支持最低版本要求: GCC: 4.3 MSVC: 14.0 Clang: Yes 提案: N1757 C++编译器因为实现方式的原因，对右尖括号的处理不是那么智能，比如： typedef std::vector&lt;int&gt; IntVector; typedef std::list&lt;std::vector&lt;int&gt; &gt; IntVecList; void func1(std::list&lt;std::vector&lt;int&gt; &gt; = IntVecList()); void func2(std::vector&lt;int&gt; = IntVector()); 这里&gt; &gt;，&gt; &gt; =和&gt; =中间都加了空格，才得以正确编译通过，如果不加空格，编译器就会识别成错误的符号，&gt;&gt;是按位右移操作符，&gt;=是大于等于比较符，&gt;&gt;=就不知道是识别成&gt;&gt; =还是&gt; &gt;=了。 在C++11中，对第一种情况做了改良，能够正常识别出&gt;&gt;了，也就是说下面这条代码也是合法的了： typedef std::list&lt;std::vector&lt;int&gt;&gt; IntVecList; 实在是个微小的改进。"},"c-11-rvalue-ref":{id:"c-11-rvalue-ref",title:"右值引用",category:"",url:" /C++11/rvalue-ref/",content:"编译器支持最低版本要求: GCC: 4.3(v1.0) 4.5(v2.1) 4.6(v3.0) MSVC: 16.0 Clang: Yes 提案: v1.0 - N2118 v2.0 - N2844 v2.1 - N2844+ v3.0 - N3053"},"c-11-static-assert":{id:"c-11-static-assert",title:"静态断言",category:"",url:" /C++11/static-assert/",content:"编译器支持最低版本要求: GCC: 4.3 MSVC: 16.0 Clang: 2.9 提案: N1720"},"c-11-strongly-typed-enum":{id:"c-11-strongly-typed-enum",title:"强类型枚举",category:"",url:" /C++11/strongly-typed-enum/",content:"编译器支持最低版本要求: GCC: 4.4 MSVC: 17.0 Clang: 2.9 提案: N2347"},"c-11-template-aliases":{id:"c-11-template-aliases",title:"模板别名",category:"",url:" /C++11/template-aliases/",content:"编译器支持最低版本要求: GCC: 4.7 MSVC: 18.0 Clang: 3.0 提案: N2258"},"c-11-thread-local-storage":{id:"c-11-thread-local-storage",title:"线程本地存储",category:"",url:" /C++11/thread-local-storage/",content:"编译器支持最低版本要求: GCC: 4.4 4.8 MSVC: 19.0 Clang: 3.3 提案: N2659"},"c-11-trailing-function-return-types":{id:"c-11-trailing-function-return-types",title:"过滤函数返回类型",category:"",url:" /C++11/trailing-function-return-types/",content:"编译器支持最低版本要求: GCC: 4.4 MSVC: 16.0 Clang: 2.9 提案: N2541"},"c-11-type-traits":{id:"c-11-type-traits",title:"类型萃取",category:"",url:" /C++11/type-traits/",content:"编译器支持最低版本要求: GCC: 4.3 MSVC: 14.0 Clang: 3.0 提案: N1836"},"c-11-unicode-string-literals":{id:"c-11-unicode-string-literals",title:"Unicode字面量字符串",category:"",url:" /C++11/unicode-string-literals/",content:"编译器支持最低版本要求: GCC: 4.4 MSVC: 19.0 Clang: 3.0 提案: N2442"},"c-11-unrestricted-unions":{id:"c-11-unrestricted-unions",title:"非受限联合体",category:"",url:" /C++11/unrestricted-unions/",content:"编译器支持最低版本要求: GCC: 4.6 MSVC: 19.0 Clang: 3.0 提案: N2544"},"c-11-user-defined-literals":{id:"c-11-user-defined-literals",title:"用户自定义字面量",category:"",url:" /C++11/user-defined-literals/",content:"编译器支持最低版本要求: GCC: 4.7 MSVC: 19.0 Clang: 3.1 提案: N2765"},"c-11-variadic-templates":{id:"c-11-variadic-templates",title:"可变参数模板",category:"",url:" /C++11/variadic-templates/",content:"编译器支持最低版本要求: GCC: 4.3(v0.9) 4.4(v1.0) MSVC: 18.0 Clang: 2.9(v1.0) 提案: v0.9 - N2242 v1.0 - N2555"},"c-14-binary-literals":{id:"c-14-binary-literals",title:"二进制字面量",category:"",url:" /C++14/binary-literals/",content:"编译器支持最低版本要求: GCC: 4.3 4.9 MSVC: 19.0 Clang: 2.9 提案: N3472"},"c-14-clarifying-memory-allocation":{id:"c-14-clarifying-memory-allocation",title:"澄清内存分配",category:"",url:" /C++14/clarifying-memory-allocation/",content:"编译器支持最低版本要求: GCC: N A MSVC: N A Clang: 3.4 提案: N3664"},"c-14-constexpr-for-array":{id:"c-14-constexpr-for-array",title:"&amp;lt;array&amp;gt;的常量表达式",category:"",url:" /C++14/constexpr-for-array/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3470"},"c-14-constexpr-for-chrono":{id:"c-14-constexpr-for-chrono",title:"&amp;lt;chrono&amp;gt;的常量表达式",category:"",url:" /C++14/constexpr-for-chrono/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3469"},"c-14-constexpr-for-complex":{id:"c-14-constexpr-for-complex",title:"&amp;lt;complex&amp;gt;的常量表达式",category:"",url:" /C++14/constexpr-for-complex/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3302"},"c-14-constexpr-for-initializer-list-utility-and-tuple":{id:"c-14-constexpr-for-initializer-list-utility-and-tuple",title:"&amp;lt;initializer_list&amp;gt;，&amp;lt;utility&amp;gt;和&amp;lt;tuple&amp;gt;的常量表达式",category:"",url:" /C++14/constexpr-for-initializer_list-utility-and-tuple/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3471"},"c-14-decltype-auto-return-type-deduction-for-normal-functions":{id:"c-14-decltype-auto-return-type-deduction-for-normal-functions",title:"普通函数返回值类型推导",category:"",url:" /C++14/decltype(auto)-return-type-deduction-for-normal-functions/",content:"编译器支持最低版本要求: GCC: 4.8 4.9 MSVC: 19.0 Clang: 3.3 3.4 提案: N3638"},"c-14-deprecated-attribute":{id:"c-14-deprecated-attribute",title:"废弃的属性",category:"",url:" /C++14/deprecated-attribute/",content:"编译器支持最低版本要求: GCC: 4.9 MSVC: 19.0 Clang: 3.4 提案: N3760"},"c-14-dual-range-std-equal-std-is-permutation-std-mismatch":{id:"c-14-dual-range-std-equal-std-is-permutation-std-mismatch",title:"双范围的std::equal, std::is_permutation, std::mismatch",category:"",url:" /C++14/dual-range-std-equal-std-is_permutation-std-mismatch/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3671"},"c-14-extended-constexpr":{id:"c-14-extended-constexpr",title:"扩展常量表达式",category:"",url:" /C++14/extended-constexpr/",content:"编译器支持最低版本要求: GCC: 5 MSVC: 19.1 Clang: 3.4 提案: N3652"},"c-14-fixing-constexpr-member-function-without-const":{id:"c-14-fixing-constexpr-member-function-without-const",title:"修复成员函数常量表达式不能带const修饰",category:"",url:" /C++14/fixing-constexpr-member-function-without-const/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3669"},"c-14-generic-plymorphic-lambda":{id:"c-14-generic-plymorphic-lambda",title:"Lambda表达式的泛型和多态",category:"",url:" /C++14/generic-plymorphic-lambda/",content:"编译器支持最低版本要求: GCC: 4.9 MSVC: 19.0 Clang: 3.4 提案: N3649"},"c-14-heterogeneous-associative-lookup":{id:"c-14-heterogeneous-associative-lookup",title:"关联容器异构比较查找算法",category:"",url:" /C++14/heterogeneous-associative-lookup/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3657"},"c-14-improved-std-integral-constant":{id:"c-14-improved-std-integral-constant",title:"改进std::integral_constant",category:"",url:" /C++14/improved-std-integral_constant/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3545"},"c-14-initialized-generalized-lambda-captures":{id:"c-14-initialized-generalized-lambda-captures",title:"初始化和泛化lambda表达式捕获列表",category:"",url:" /C++14/initialized-generalized-lambda-captures/",content:"编译器支持最低版本要求: GCC: 4.5 4.9 MSVC: 19.0 Clang: 3.4 提案: N3648"},"c-14-member-initializers-and-aggregates":{id:"c-14-member-initializers-and-aggregates",title:"成员初始化和聚合",category:"",url:" /C++14/member-initializers-and-aggregates/",content:"编译器支持最低版本要求: GCC: 5 MSVC: 19.1 Clang: 3.3 提案: N3653"},"c-14-null-forward-iterators":{id:"c-14-null-forward-iterators",title:"Null前向迭代器",category:"",url:" /C++14/null-forward-iterators/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3644"},"c-14-single-quote-as-digit-separator":{id:"c-14-single-quote-as-digit-separator",title:"单引号作为数字分隔符",category:"",url:" /C++14/single-quote-as-digit-separator/",content:"编译器支持最低版本要求: GCC: 4.9 MSVC: 19.0 Clang: 3.4 提案: N3781"},"c-14-sized-deallocation":{id:"c-14-sized-deallocation",title:"释放指定大小的内存",category:"",url:" /C++14/sized-deallocation/",content:"编译器支持最低版本要求: GCC: 5 MSVC: 19.0 Clang: 3.4 提案: N3778"},"c-14-std-exchange":{id:"c-14-std-exchange",title:"std::exchage",category:"",url:" /C++14/std-exchange/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3668"},"c-14-std-get-t":{id:"c-14-std-get-t",title:"std::get&amp;lt;T&amp;gt;()",category:"",url:" /C++14/std-get_T/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3670"},"c-14-std-integer-squence":{id:"c-14-std-integer-squence",title:"std::integer_squence",category:"",url:" /C++14/std-integer_squence/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3658"},"c-14-std-quoted":{id:"c-14-std-quoted",title:"std::quoted",category:"",url:" /C++14/std-quoted/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3654"},"c-14-std-result-of-and-sfinae":{id:"c-14-std-result-of-and-sfinae",title:"std::result_of和SFINAE",category:"",url:" /C++14/std-result_of-and-SFINAE/",content:`编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: Yes 提案: N3462 std::result_of是C++11标准中提供的一种类型萃取工具，用于获取函数调用结果的类型，它的定义如下： template &lt;class F, class... Args&gt; class result_of&lt;F(Args...)&gt;; 其中，F是函数类型，Args是参数类型。std::result_of&lt;F(Args...)&gt;将返回函数调用表达式f(args...)的返回类型。例如： int func(double d, int i) { return d * i; } using result_type = std::result_of&lt;decltype(func)&amp;(double, int)&gt;::type; static_assert(std::is_same&lt;result_type, int&gt;::value, "result type should be int"); 上述代码中，std::result_of&lt;decltype(func)&amp;(double, int)&gt;::type返回了函数func在调用时的返回类型，即int。这样我们就可以在编译时获取函数调用表达式的返回类型，进而实现更加灵活和复杂的模板元编程。 std::result_of的实现依赖于SFINAE技术。在调用std::result_of&lt;F(Args...)&gt;时，编译器会先尝试调用一个辅助函数，该函数接收一个参数类型为F，参数类型为Args...的参数列表，然后根据调用结果的类型，推导出std::result_of&lt;F(Args...)&gt;的返回类型。如果调用辅助函数失败，编译器会尝试使用其他函数重载，直到找到匹配的函数。 SFINAE技术是通过函数重载和模板参数推导失败来实现的。在调用一个函数时，编译器会首先进行函数匹配，尝试找到与函数调用参数类型和个数最匹配的函数。如果找到了匹配的函数，则调用该函数。否则，编译器会尝试使用其他函数重载，如果所有的函数重载都无法匹配，则编译器将会报错。 SFINAE技术通过在模板参数推导时失败来实现函数重载的选择。例如，如果在模板参数推导时某个参数类型无法匹配，编译器会认为这个模板实例化不可行，并尝试使用其他模板实例化。这样就可以根据不同的模板实例化，选择不同的函数重载。 因此，在使用std::result_of和SFINAE技术时，需要注意模板参数推导的情况，以避免出现不必要的错误。同时，需要了解模板元编程的相关知识，以便更好地理解这些技术的实现原理。 SFINAE SFINAE是C++模板元编程中的一种技术，全称为Substitution Failure Is Not An Error，即“替换失败不是一个错误”。这个技术是指在编译时，如果模板实例化的过程中发生了替换失败的情况，编译器不会报错，而是会尝试使用其他的模板实例化，这样就可以通过一系列判断选择最合适的模板实例。 SFINAE通常用于解决函数重载中的一些问题。在C++中，函数重载是通过函数的参数类型和个数来区分的。当函数调用时，编译器会尝试匹配所有可行的重载函数，如果找到了匹配的函数，就会调用该函数。但是，当函数重载的参数类型过于复杂，或者函数模板的参数类型不确定时，编译器可能无法确定最佳匹配的函数。这时，SFINAE技术就可以派上用场了。 SFINAE的实现通常是通过模板参数推导失败来实现的。例如，假设我们有一个模板函数，用于检查某个类型是否具有一个成员函数： template &lt;typename T&gt; struct has_member_function_foo { template &lt;typename U&gt; static auto test(U* p) -&gt; decltype(p-&gt;foo(), std::true_type{}); static auto test(...) -&gt; std::false_type; static constexpr bool value = decltype(test((T*)nullptr))::value; }; 这个模板函数中，我们使用了两个重载的test函数。第一个test函数尝试访问T类型的一个名为foo的成员函数，如果可以访问，则返回一个std::true_type类型的值。第二个test函数是一个catch-all函数，用于处理访问T类型的foo成员函数失败的情况。在实际调用时，我们可以使用类似下面的方式来判断某个类型是否具有一个名为foo的成员函数： struct A { void foo() {} }; struct B {}; static_assert(has_member_function_foo&lt;A&gt;::value == true, "A has foo"); static_assert(has_member_function_foo&lt;B&gt;::value == false, "B doesn't have foo"); 在上面的示例中，我们使用static_assert语句来检查是否能够访问某个类型的foo成员函数。如果访问成功，则has_member_function_foo的value成员将被设置为true，否则将被设置为false。 需要注意的是，SFINAE技术需要谨慎使用，因为它可能会导致模板实例化的过程变得非常复杂。在实际使用中，建议使用简单的技巧，比如函数重载和if constexpr语句，来实现类似的功能。`},"c-14-std-shared-timed-mutex":{id:"c-14-std-shared-timed-mutex",title:"std::shared_timed_mutex",category:"",url:" /C++14/std-shared_timed_mutex/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3659"},"c-14-tweaked-wording-for-contextual-conversions":{id:"c-14-tweaked-wording-for-contextual-conversions",title:"调整上下文转换",category:"",url:" /C++14/tweaked-wording-for-contextual-conversions/",content:"编译器支持最低版本要求: GCC: 4.9 MSVC: 18.0 Clang: 3.4 提案: N3323"},"c-14-user-defined-literals-for-chrono-and-string":{id:"c-14-user-defined-literals-for-chrono-and-string",title:"为chrono和string提供用户自定义字面量",category:"",url:" /C++14/user-defined-literals-for-chrono-and-string/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3642"},"c-14-variable-templates":{id:"c-14-variable-templates",title:"变量模板",category:"",url:" /C++14/variable-templates/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.4 提案: N3651"},"c-17-5b-5bfallthrough-5d-5d-attribute":{id:"c-17-5b-5bfallthrough-5d-5d-attribute",title:"&amp;#91;&amp;#91;fallthrough&amp;#93;&amp;#93;属性",category:"",url:" /C++17/%5B%5Bfallthrough%5D%5D-attribute/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 3.9 提案: P0188R1 C++17之前的标准下，有如下代码： switch (device.status()) { case sleep: device.wake(); fall thru case ready: device.run(); break; case bad: handle_error(); break; } 在C++17时可以这样写： switch (device.status()) { case sleep: device.wake(); [[fallthrough]]; case ready: device.run(); break; case bad: handle_error(); break; } 区别就是新增的[[fallthrough]]属性。如果这里不写[[fallthrough]]，编译也是能通过的，但会报诸如warning: case statement without break之类的警告。C++中switch-case默认是会继续往下走，有的时候程序员可能因为粗心会漏写break，就会导致非预期的运行逻辑，有的语言比如Go则默认会跳出当前case，C++17中新增[[fallthrough]]属性可以提醒程序员这里正常逻辑应该是怎样的。"},"c-17-5b-5bmaybe-unused-5d-5d-attribute":{id:"c-17-5b-5bmaybe-unused-5d-5d-attribute",title:"&amp;#91;&amp;#91;maybe_unused&amp;#93;&amp;#93;属性",category:"",url:" /C++17/%5B%5Bmaybe_unused%5D%5D-attribute/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 3.9 提案: P0212R1 有代码如下： bool res = step1(); step2(); etc(); 编译时可能会报警告说res变量定义了却没有使用诸如此类的话。C++17引入了[[maybe_unused]]属性，可以修改如下： [[maybe_unused]] bool res = step1(); step2(); etc(); 这样编译器就不会再对res变量没有被使用而报警告了。 除了可以修饰变量，此属性也可用于修饰函数，例如： [[maybe_unused]] void f() { *...* } int main() { }"},"c-17-5b-5bnodiscard-5d-5d-attribute":{id:"c-17-5b-5bnodiscard-5d-5d-attribute",title:"&amp;#91;&amp;#91;nodiscard&amp;#93;&amp;#93;属性",category:"",url:" /C++17/%5B%5Bnodiscard%5D%5D-attribute/",content:`编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 3.9 提案: P0189R1 C++17之前的标准下，有如下代码： struct SomeInts { bool empty(); void push_back(int); etc }; void random_fill(SomeInts &amp; container, int min, int max, int count) { container.empty(); empty it first for (int num : gen_rand(min, max, count)) container.push_back(num); } 在C++17时可以这样写： struct SomeInts { [[nodiscard]] bool empty(); void push_back(int); etc }; void random_fill(SomeInts &amp; container, int min, int max, int count) { container.empty(); empty it first for (int num : gen_rand(min, max, count)) container.push_back(num); } 加上[[nodiscard]]后，编译器发现empty()函数被调用时并没有使用它的返回值，则会报一个诸如warning: ignoring return value of 'bool empty()'的警告。 除了可以用在函数上，也可以用在类或结构体上，作用是该类或结构体被作为返回值类型时，如果不使用该返回值，则编译器警告。例如： struct [[nodiscard]] MyError { std::string message; int code; }; MyError divide(int a, int b) { if (b == 0) { return {"Division by zero", -1}; } std::cout &lt;&lt; (a b) &lt;&lt; '\\n'; return {}; } divide(1, 2); 报警告warning: ignoring return value of function declared with 'nodiscard' attribute。 建议要谨慎考虑是否真的需要使用[[nodiscard]]属性，如果确实任何情况下都没理由可以忽略掉返回值，则可以使用。`},"c-17-aggregate-initialization-of-class-with-base-classes":{id:"c-17-aggregate-initialization-of-class-with-base-classes",title:"聚合带基类的类的初始化",category:"",url:" /C++17/aggregate-initialization-of-class-with-base-classes/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 3.9 提案: P0017R1"},"c-17-allow-constant-evaluation-for-all-non-type-template-arguments":{id:"c-17-allow-constant-evaluation-for-all-non-type-template-arguments",title:"允许所有非类型模板参数进行参量计算",category:"",url:" /C++17/allow-constant-evaluation-for-all-non-type-template-arguments/",content:"编译器支持最低版本要求: GCC: 6 MSVC: Clang: 3.6 提案: N4268"},"c-17-attributes-for-namespaces-and-enumerators":{id:"c-17-attributes-for-namespaces-and-enumerators",title:"名字空间和枚举的属性",category:"",url:" /C++17/attributes-for-namespaces-and-enumerators/",content:"编译器支持最低版本要求: GCC: 4.9(namespaces) 6(enumerators) MSVC: 19.0 Clang: 3.6 提案: N4266"},"c-17-constexpr-if-statements":{id:"c-17-constexpr-if-statements",title:"if语句常量表达式",category:"",url:" /C++17/constexpr-if-statements/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 3.9 提案: P0292R2"},"c-17-constexpr-lambda-expressions":{id:"c-17-constexpr-lambda-expressions",title:"Lambda常量表达式",category:"",url:" /C++17/constexpr-lambda-expressions/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 5 提案: P0170R1"},"c-17-differing-begin-and-end-types-in-range-based-for":{id:"c-17-differing-begin-and-end-types-in-range-based-for",title:"基于范围的for循环可以拥有不同类型的begin和end",category:"",url:" /C++17/differing-begin-and-end-types-in-range-based-for/",content:"编译器支持最低版本要求: GCC: 6 MSVC: 19.1 Clang: 3.9 提案: P0184R0 C++11引入的基于范围的for循环要求begin和end（起始值和结尾值）具有相同的类型，这对于大多数情况来说并没有什么问题，比如在遍历STL容器时，总是能返回相同类型的begin和end。 但是有人觉得这个规范过于受限，于是C++17放开了这个限制，将原来的等价代码修改如下： { auto &amp;&amp; __range = for-range-initializer; auto __begin = begin-expr; auto __end = end-expr; for ( ; __begin != __end; ++__begin ) { for-range-declaration = *__begin; statement } } 与C++11中的相比，唯一的不同就是__begin和__end可以具有不同类型了，只要它们两个支持通过operator!=比较即可。 这为类作者、库作者提供了更多的灵活性。 相关链接 C++11 基于范围的for循环"},"c-17-direct-list-initialization-of-enumerations":{id:"c-17-direct-list-initialization-of-enumerations",title:"枚举直接列表初始化",category:"",url:" /C++17/direct-list-initialization-of-enumerations/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 3.9 提案: P0138R2"},"c-17-dynamic-memory-allocation-for-over-aligned-data":{id:"c-17-dynamic-memory-allocation-for-over-aligned-data",title:"为过量对齐数据动态分配内存",category:"",url:" /C++17/dynamic-memory-allocation-for-over-aligned-data/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 4 提案: P0035R4"},"c-17-elementary-string-convertions":{id:"c-17-elementary-string-convertions",title:"基础字符串转换",category:"",url:" /C++17/elementary-string-convertions/",content:"提案: P0067R5 目前主流编译器（包括GCC、MSVC、Clang、Intel C++等）均未实现。"},"c-17-fold-expressions":{id:"c-17-fold-expressions",title:"折叠表达式",category:"",url:" /C++17/fold-expressions/",content:"编译器支持最低版本要求: GCC: 6 MSVC: Clang: 3.6 提案: N4295"},"c-17-guaranteed-copy-elision":{id:"c-17-guaranteed-copy-elision",title:"保证复制省略",category:"",url:" /C++17/guaranteed-copy-elision/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 4 提案: P0135R1"},"c-17-hexadecimal-floating-point-literals":{id:"c-17-hexadecimal-floating-point-literals",title:"16进制浮点字面量",category:"",url:" /C++17/hexadecimal-floating-point-literals/",content:"编译器支持最低版本要求: GCC: 3.0 MSVC: Clang: Yes 提案: P0245R1"},"c-17-ignore-unknown-attributes":{id:"c-17-ignore-unknown-attributes",title:"忽略未知属性",category:"",url:" /C++17/ignore-unknown-attributes/",content:"编译器支持最低版本要求: GCC: Yes MSVC: Clang: 3.9 提案: P0283R2"},"c-17-improving-std-pair-and-std-tuple":{id:"c-17-improving-std-pair-and-std-tuple",title:"改进std::pair和std::tuple",category:"",url:" /C++17/improving-std-pair-and-std-tuple/",content:"编译器支持最低版本要求: GCC: Yes MSVC: 19.0 Clang: 4 提案: N4387"},"c-17-init-statements-for-if-and-switch":{id:"c-17-init-statements-for-if-and-switch",title:"if和switch的初始化语句",category:"",url:" /C++17/init-statements-for-if-and-switch/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 3.9 提案: P0305R1 C++17之前的标准下，有如下代码： QVariant var = getAnswer(); if (var.isValid()) use(var); 在C++17时可以这样写： if (QVariant var = getAnswer(); var.isValid()) use(var); 除了if外，switch也支持这种新写法： switch (Device dev = get_device(); dev.state()) { case sleep: *...* break; case ready: *...* break; case bad: *...* break; } 这个写法秉持了C++相对于C的一个理念上的区别：变量 对象在需要时才声明和定义。这里还更进一步，缩短变量 对象的生命周期。"},"c-17-inline-variables":{id:"c-17-inline-variables",title:"Inline变量",category:"",url:" /C++17/inline-variables/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 3.9 提案: P0386R2 C++17之前的标准，如果在多个文件中使用同一个全局变量或类的静态成员变量，需要在头文件中声明，在cpp文件中定义，例如： foo.h extern int foo; struct Foo { static int foo; }; foo.cpp int foo = 10; int Foo::foo = 10; C++17扩展了inline关键字的功能，只需要在头文件中声明并定义即可达到相同的效果： foo.h inline int foo = 10; struct Foo { static inline int foo = 10; };"},"c-17-lambda-capture-of-star-this":{id:"c-17-lambda-capture-of-star-this",title:"Lambda表达式可以捕获*this",category:"",url:" /C++17/lambda-capture-of-star-this/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 3.9 提案: P0018R3 C++11和C++14中，lambda只能捕获this的引用，这在并行程序或异步程序中可能会很难处理好this指向的对象的生命周期，C++17中允许捕获*this，也就是以值类型捕获，lambda就能访问到this指向的对象的另一份拷贝： struct MyObj { int value {123}; auto getValueCopy() { return [*this] { return value; }; } auto getValueRef() { return [this] { return value; }; } }; MyObj mo; auto valueCopy = mo.getValueCopy(); auto valueRef = mo.getValueRef(); mo.value = 321; valueCopy(); 123 valueRef(); 321 要注意的是[&amp;,this]这样的写法也是可以的，目的是兼容C++11和C++14的代码，但这样写是多余的，因为[&amp;]和[=]隐含捕获了this。新的写法可能是[=, *this]。"},"c-17-make-exception-specifications-part-of-the-type-system":{id:"c-17-make-exception-specifications-part-of-the-type-system",title:"将异常规范作为类型系统的一部分",category:"",url:" /C++17/make-exception-specifications-part-of-the-type-system/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 4 提案: P0012R1"},"c-17-matching-of-template-template-arguments-excludes-compatible-templates":{id:"c-17-matching-of-template-template-arguments-excludes-compatible-templates",title:"匹配排除兼容模板后的模板模板参数",category:"",url:" /C++17/matching-of-template-template-arguments-excludes-compatible-templates/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 4 提案: P0522R0"},"c-17-nested-namespace-definition":{id:"c-17-nested-namespace-definition",title:"嵌套名字空间定义",category:"",url:" /C++17/nested-namespace-definition/",content:"编译器支持最低版本要求: GCC: 6 MSVC: 19.0 Clang: 3.6 提案: N4230 C++17之前的标准下，有如下代码： namespace A { namespace B { namespace C { struct Foo { }; ... } } } 在C++17时可以这样写： namespace A::B::C { struct Foo { }; ... } 一个小小的语法糖，让代码更简洁。"},"c-17-new-auto-rules-for-direct-list-initialization":{id:"c-17-new-auto-rules-for-direct-list-initialization",title:"为直接列表初始化设置新的auto规则",category:"",url:" /C++17/new-auto-rules-for-direct-list-initialization/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.8 提案: N3922"},"c-17-new-specification-for-inheriting-constructors":{id:"c-17-new-specification-for-inheriting-constructors",title:"继承构造函数的新规范",category:"",url:" /C++17/new-specification-for-inheriting-constructors/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 3.9 提案: P0136R1"},"c-17-non-type-template-parameters-with-auto-type":{id:"c-17-non-type-template-parameters-with-auto-type",title:"用auto类型作为无类型的模板参数",category:"",url:" /C++17/non-type-template-parameters-with-auto-type/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 4 提案: P0127R2"},"c-17-pack-expansions-in-using-declarations":{id:"c-17-pack-expansions-in-using-declarations",title:"在using声明中使用打包扩张(pack expansion)",category:"",url:" /C++17/pack-expansions-in-using-declarations/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 4 提案: P0195R2"},"c-17-remove-deprecated-exception-specifications-from-c-17":{id:"c-17-remove-deprecated-exception-specifications-from-c-17",title:"删除C++17中废弃的异常规范",category:"",url:" /C++17/remove-deprecated-exception-specifications-from-C++17/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 4 提案: P0003R5"},"c-17-remove-deprecated-operator-bool":{id:"c-17-remove-deprecated-operator-bool",title:"删除废弃的operator++&amp;#40;bool&amp;#41;",category:"",url:" /C++17/remove-deprecated-operator++(bool)/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 3.8 提案: P0002R1"},"c-17-remove-deprecated-use-of-the-register-keyword":{id:"c-17-remove-deprecated-use-of-the-register-keyword",title:"删除废弃的register关键字",category:"",url:" /C++17/remove-deprecated-use-of-the-register-keyword/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 3.8 提案: P0001R1"},"c-17-removing-trigraphs":{id:"c-17-removing-trigraphs",title:"删除三联符",category:"",url:" /C++17/removing-trigraphs/",content:"编译器支持最低版本要求: GCC: 5.1 MSVC: 16.0 Clang: 3.5 提案: N4086"},"c-17-splicing-maps-and-sets":{id:"c-17-splicing-maps-and-sets",title:"拼接map和set",category:"",url:" /C++17/splicing-maps-and-sets/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 提案: P0083R3"},"c-17-standardization-of-parallelism-ts":{id:"c-17-standardization-of-parallelism-ts",title:"并行的技术规范标准化",category:"",url:" /C++17/standardization-of-parallelism-ts/",content:"提案: P0024R2 目前主流编译器（包括GCC、MSVC、Clang、Intel C++等）均未实现。"},"c-17-static-assert-with-no-message":{id:"c-17-static-assert-with-no-message",title:"无消息的静态断言",category:"",url:" /C++17/static_assert-with-no-message/",content:'编译器支持最低版本要求: GCC: 6 MSVC: 19.1 Clang: 2.5 提案: N3928 C++11或C++14有如下代码： static_assert(sizeof(short) == 2, "sizeof(short) == 2") 在C++17时可以这样写： static_assert(sizeof(short) == 2) 两者达到相同的效果，都会在编译时静态断言失败时输出static assertion failure: sizeof(short) == 2，一个小小的语法糖，代码更简洁，少冗余。'},"c-17-std-shared-mutex-untimed":{id:"c-17-std-shared-mutex-untimed",title:"std::shared_mutex（untimed）",category:"",url:" /C++17/std-shared_mutex(untimed)/",content:"编译器支持最低版本要求: GCC: 6 MSVC: 19.0 Clang: 3.7 提案: N4508"},"c-17-std-string-view":{id:"c-17-std-string-view",title:"std::string_view",category:"",url:" /C++17/std-string_view/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 4.0 提案: N3921"},"c-17-std-uncaught-exceptions":{id:"c-17-std-uncaught-exceptions",title:"std::uncaught_exceptions",category:"",url:" /C++17/std-uncaught_exceptions/",content:"编译器支持最低版本要求: GCC: 6 MSVC: 19.0 Clang: 3.7 提案: N4259"},"c-17-stricter-expression-evaluation-order":{id:"c-17-stricter-expression-evaluation-order",title:"更严格的表达式估值顺序",category:"",url:" /C++17/stricter-expression-evaluation-order/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 4 提案: P0145R3"},"c-17-structured-bindings":{id:"c-17-structured-bindings",title:"结构化绑定",category:"",url:" /C++17/structured-bindings/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 4 提案: P0217R3 C++11加入了std::get，可以对std::tuple，std::pair，std::array进行操作，获取指定序号的元素，例如： auto p = std::make_pair(1, 2); auto t = std::make_tupe(1, 2, 3); std::array&lt;int&gt; a = {1, 2, 3, 4}; auto p0 = std::get&lt;0&gt;(p); auto t1 = std::get&lt;1&gt;(t); auto a2 = std::get&lt;2&gt;(a); 同时也加入了std::tie来获取元素，并以这些元素的值创建一个新的std::tuple，例如： int t0, t1, t2; std::tie(t0, t1, t2) = t; 以上std::tie会创建一个新的std::tuple对象，该对象保持了对t0，t1，t2的左值引用，所以当再将t赋值给此对象时，就把t中对应位置的元素的值赋值给t0，t1，t2了。 C++17中引入了反结构化初始化，允许写出这样的代码： auto [ x, y, z ] = expr; 其中expr的类型，是类tuple的对象，它的元素可以被绑定到x，y和z上（就是该语句声明的那几个变量）。类tuple的对象可以是std::tuple，std::pair，std::array或聚合类型的结构体以及普通数组，例如： using Coordinate = std::pair&lt;int, int&gt;; Coordinate origin() { return Coordinate{0, 0}; } const auto [ x, y ] = origin(); int a[3] = {1,2,3}; auto [a1, a2, a3] = a; 这种写法大大简化了代码，不但能达到C++11中引入的std::get和std::tie的效果，还增加了对聚合类型的结构体以及普通数组的支持。"},"c-17-template-argument-deduction-for-class-template":{id:"c-17-template-argument-deduction-for-class-template",title:"类模板的模板参数推导",category:"",url:" /C++17/template-argument-deduction-for-class-template/",content:"编译器支持最低版本要求: GCC: 7 MSVC: Clang: 5 提案: P0091R3"},"c-17-typename-in-a-template-template-parameter":{id:"c-17-typename-in-a-template-template-parameter",title:"模板模板参数中使用typename",category:"",url:" /C++17/typename-in-a-template-template-parameter/",content:"编译器支持最低版本要求: GCC: 5.0 MSVC: 19.0 Clang: 3.5 提案: N4051"},"c-17-u8-character-literals":{id:"c-17-u8-character-literals",title:"u8字符字面量",category:"",url:" /C++17/u8-character-literals/",content:"编译器支持最低版本要求: GCC: 6 MSVC: 19.0 Clang: 3.6 提案: N4267"},"c-17-unary-fold-expressions-and-empty-parameter-pack":{id:"c-17-unary-fold-expressions-and-empty-parameter-pack",title:"一元折叠表达式和空参打包",category:"",url:" /C++17/unary-fold-expressions-and-empty-parameter-pack/",content:"编译器支持最低版本要求: GCC: 6 MSVC: Clang: 3.9 提案: P0036R0"},"c-17-using-attribute-namespaces-without-repetition":{id:"c-17-using-attribute-namespaces-without-repetition",title:"不重复地使用带属性的名字空间",category:"",url:" /C++17/using-attribute-namespaces-without-repetition/",content:"编译器支持最低版本要求: GCC: 7 MSVC: 19.1 Clang: 3.9 提案: P0028R4"}}</script><script src=/scripts/lunr.min.js></script><script src=/scripts/search.js></script></article><div class=content><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div style=line-height:2.5>感觉不错，小额赞助一下！</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>打赏</span></button><div id=QR style=display:block><div id=wechat style=display:inline-block><a href=wxp://f2f0JOwB8LU7CU53fcitPGIuC6lYMX1q-nlk class=fancybox rel=group><img id=wechat_qr src=https://blogassets.ismisv.com/assets/images/wepay.jpg alt="missdeer WeChat Pay"></a><p>微信扫一扫</div><div id=wechat style=display:inline-block><a href="alipays://platformapi/startapp?appId=10000007&qrcode=https://qr.alipay.com/tsx00458kzwvymgbjk0ci9e" class=fancybox rel=group><img id=alipay_qr src=https://blogassets.ismisv.com/assets/images/alipay.jpg alt="missdeer AliPay"></a><p>支付宝扫一扫</div></div></div></div><div class=content></hr><div style=color:#b3b3b3;font-size:.7em><p>Hosted by <a href=https://app.netlify.com/ style=font-weight:700>Netlify</a>,
本站由 <a href=https://minidump.info target=_blank>@missdeer</a> 创建，由 <a href=https://jekyllrb.com target=_blank>Jekyll</a> 于 2024-11-07 生成，感谢<a href=https://github.com/CloudCannon target=_blank> CloudCannon </a>制作的theme： <a href=https://github.com/CloudCannon/edition-jekyll-template target=_blank>Edition</a> ，感谢<a href=https://letsencrypt.org/ target=_blank> Let's Encrypt </a>提供免费的SSL证书服务。本站点采用<a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>知识共享署名-非商业性使用-相同方式共享
4.0 国际许可协议</a>进行许可。&copy; 2017 - 2024</div></div></section><script>document.getElementById("open-nav").addEventListener("click",function(){document.body.classList.toggle("nav-open")})</script>