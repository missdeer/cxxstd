<!doctype html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Jekyll v3.8.6"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700"><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/css/main.min.css><link rel=stylesheet href=https://blogassets.ismisv.com/css/pay.min.css><link rel=apple-touch-icon href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/apple-touch-icon.png><link rel=icon type=image/png href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/touch-icon.png sizes=192x192><link rel=icon type=image/png href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/images/favicon.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css media=print onload='this.media="all"'><style>body{font-family:lxgw wenkai screen,sans-serif}</style><link type=application/atom+xml rel=alternate href=https://minidump.info/feed.xml title="不那么新的modern C++简要学习笔记"><title>Lambda表达式 - 不那么新的modern C++简要学习笔记</title><meta property="og:title" content="Lambda表达式"><meta name=description content="  编译器支持最低版本要求:      GCC: 4.5(v1.1)    MSVC: 16.0    Clang: 3.1    提案: v0.9 - N2550/v1.0 - N2658/v1.1 - N2927"><meta property="og:description" content="  编译器支持最低版本要求:      GCC: 4.5(v1.1)    MSVC: 16.0    Clang: 3.1    提案: v0.9 - N2550/v1.0 - N2658/v1.1 - N2927"><link rel=canonical href=https://minidump.info/C++11/lambda/><meta property="og:url" content="https://minidump.info/C++11/lambda/"><meta property="og:site_name" content="不那么新的modern C++简要学习笔记"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"Lambda表达式","description":"  编译器支持最低版本要求:      GCC: 4.5(v1.1)    MSVC: 16.0    Clang: 3.1    提案: v0.9 - N2550/v1.0 - N2658/v1.1 - N2927","logo":"https://minidump.info/siteicon.png","url":"https://minidump.info/C++11/lambda/"}</script><script>(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-52744860-1","auto"),ga("send","pageview")</script><header><h1><a href=/><img src=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/images/emblem.svg width=40 height=40 alt="不那么新的modern C++简要学习笔记 logo"></a>
不那么新的modern C++简要学习笔记
<button type=button class=open-nav id=open-nav></button></h1><form action=/search/><input name=q id=search-input placeholder=Search autofocus>
<input type=submit value=Search style=display:none></form><nav class=full-navigation><ul><li class="nav-item top-level"><a href=/>前言</a></ul><ul><li class="nav-item top-level current"><a href=/C++11/alignas/>C++11</a><ul><li class=nav-item><a href=/C++11/alignas/>Alignas</a><li class=nav-item><a href=/C++11/alignof/>Alignof</a><li class=nav-item><a href=/C++11/atomic-operations/>原子操作</a><li class=nav-item><a href=/C++11/attributes/>属性</a><li class=nav-item><a href=/C++11/auto/>自动类型推导</a><li class=nav-item><a href=/C++11/c99-preprocessor/>C99兼容预处理器</a><li class=nav-item><a href=/C++11/constexpr/>常量表达式</a><li class=nav-item><a href=/C++11/decltype/>decltype</a><li class=nav-item><a href=/C++11/defaulted-and-deleted-functions/>缺省函数和可删除函数</a><li class=nav-item><a href=/C++11/delegating-constructors/>委托构造函数</a><li class=nav-item><a href=/C++11/dynamic-initialization-and-destruction-with-concurrency/>动态初始化和并发析构（魔法静态）</a><li class=nav-item><a href=/C++11/dynamic-pointer-safety/>动态指针安全（垃圾回收接口）</a><li class=nav-item><a href=/C++11/explicit-conversion-operators/>显式转换操作符</a><li class=nav-item><a href=/C++11/extended-friend-declarations/>扩展的friend声明</a><li class=nav-item><a href=/C++11/extern-template/>外部模板</a><li class=nav-item><a href=/C++11/forward-enum-declarations/>前向声明枚举类型</a><li class=nav-item><a href=/C++11/inheriting-constructors/>继承构造函数</a><li class=nav-item><a href=/C++11/initializer-lists/>初始化列表</a><li class=nav-item><a href=/C++11/inline-namespace/>内联名字空间</a><li class="nav-item current"><a href=/C++11/lambda/>Lambda表达式</a><li class=nav-item><a href=/C++11/local-and-unnamed-types-as-template-parameters/>本地和匿名类型作为模板参数</a><li class=nav-item><a href=/C++11/long-long/>long long类型</a><li class=nav-item><a href=/C++11/money-time-hexfloat-IO-manipulators/>货币、时间、16进制浮点I/O操作</a><li class=nav-item><a href=/C++11/new-characger-type/>新字符类型</a><li class=nav-item><a href=/C++11/noexcept/>noexcept关键字</a><li class=nav-item><a href=/C++11/non-static-data-member-initializers/>非静态数据成员初始化</a><li class=nav-item><a href=/C++11/nullptr/>Nullptr</a><li class=nav-item><a href=/C++11/override-and-final/>override和final关键字</a><li class=nav-item><a href=/C++11/range-for-loop/>基于范围的for循环</a><li class=nav-item><a href=/C++11/raw-string-literals/>原始字面量字符串</a><li class=nav-item><a href=/C++11/ref-qualifiers/>扩展移动语义</a><li class=nav-item><a href=/C++11/right-angle-brackets/>右尖括号</a><li class=nav-item><a href=/C++11/rvalue-ref/>右值引用</a><li class=nav-item><a href=/C++11/static-assert/>静态断言</a><li class=nav-item><a href=/C++11/strongly-typed-enum/>强类型枚举</a><li class=nav-item><a href=/C++11/template-aliases/>模板别名</a><li class=nav-item><a href=/C++11/thread-local-storage/>线程本地存储</a><li class=nav-item><a href=/C++11/trailing-function-return-types/>过滤函数返回类型</a><li class=nav-item><a href=/C++11/type-traits/>类型萃取</a><li class=nav-item><a href=/C++11/unicode-string-literals/>Unicode字面量字符串</a><li class=nav-item><a href=/C++11/unrestricted-unions/>非受限联合体</a><li class=nav-item><a href=/C++11/user-defined-literals/>用户自定义字面量</a><li class=nav-item><a href=/C++11/variadic-templates/>可变参数模板</a></ul><li class="nav-item top-level"><a href=/C++14/binary-literals/>C++14</a><ul><li class=nav-item><a href=/C++14/binary-literals/>二进制字面量</a><li class=nav-item><a href=/C++14/clarifying-memory-allocation/>澄清内存分配</a><li class=nav-item><a href=/C++14/constexpr-for-array/>&lt;array>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-chrono/>&lt;chrono>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-complex/>&lt;complex>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-initializer_list-utility-and-tuple/>&lt;initializer_list>，&lt;utility>和&lt;tuple>的常量表达式</a><li class=nav-item><a href=/C++14/decltype(auto)-return-type-deduction-for-normal-functions/>普通函数返回值类型推导</a><li class=nav-item><a href=/C++14/deprecated-attribute/>废弃的属性</a><li class=nav-item><a href=/C++14/dual-range-std-equal-std-is_permutation-std-mismatch/>双范围的std::equal, std::is_permutation, std::mismatch</a><li class=nav-item><a href=/C++14/extended-constexpr/>扩展常量表达式</a><li class=nav-item><a href=/C++14/fixing-constexpr-member-function-without-const/>修复成员函数常量表达式不能带const修饰</a><li class=nav-item><a href=/C++14/generic-plymorphic-lambda/>Lambda表达式的泛型和多态</a><li class=nav-item><a href=/C++14/heterogeneous-associative-lookup/>关联容器异构比较查找算法</a><li class=nav-item><a href=/C++14/improved-std-integral_constant/>改进std::integral_constant</a><li class=nav-item><a href=/C++14/initialized-generalized-lambda-captures/>初始化和泛化lambda表达式捕获列表</a><li class=nav-item><a href=/C++14/member-initializers-and-aggregates/>成员初始化和聚合</a><li class=nav-item><a href=/C++14/null-forward-iterators/>Null前向迭代器</a><li class=nav-item><a href=/C++14/single-quote-as-digit-separator/>单引号作为数字分隔符</a><li class=nav-item><a href=/C++14/sized-deallocation/>释放指定大小的内存</a><li class=nav-item><a href=/C++14/std-exchange/>std::exchage</a><li class=nav-item><a href=/C++14/std-get_T/>std::get&lt;T>()</a><li class=nav-item><a href=/C++14/std-integer_squence/>std::integer_squence</a><li class=nav-item><a href=/C++14/std-quoted/>std::quoted</a><li class=nav-item><a href=/C++14/std-result_of-and-SFINAE/>std::result_of和SFINAE</a><li class=nav-item><a href=/C++14/std-shared_timed_mutex/>std::shared_timed_mutex</a><li class=nav-item><a href=/C++14/tweaked-wording-for-contextual-conversions/>调整上下文转换</a><li class=nav-item><a href=/C++14/user-defined-literals-for-chrono-and-string/>为chrono和string提供用户自定义字面量</a><li class=nav-item><a href=/C++14/variable-templates/>变量模板</a></ul><li class="nav-item top-level"><a href=/C++17/%5B%5Bfallthrough%5D%5D-attribute/>C++17</a><ul><li class=nav-item><a href=/C++17/%5B%5Bfallthrough%5D%5D-attribute/>[[fallthrough]]属性</a><li class=nav-item><a href=/C++17/%5B%5Bmaybe_unused%5D%5D-attribute/>[[maybe_unused]]属性</a><li class=nav-item><a href=/C++17/%5B%5Bnodiscard%5D%5D-attribute/>[[nodiscard]]属性</a><li class=nav-item><a href=/C++17/aggregate-initialization-of-class-with-base-classes/>聚合带基类的类的初始化</a><li class=nav-item><a href=/C++17/allow-constant-evaluation-for-all-non-type-template-arguments/>允许所有非类型模板参数进行参量计算</a><li class=nav-item><a href=/C++17/attributes-for-namespaces-and-enumerators/>名字空间和枚举的属性</a><li class=nav-item><a href=/C++17/constexpr-if-statements/>if语句常量表达式</a><li class=nav-item><a href=/C++17/constexpr-lambda-expressions/>Lambda常量表达式</a><li class=nav-item><a href=/C++17/differing-begin-and-end-types-in-range-based-for/>基于范围的for循环可以拥有不同类型的begin和end</a><li class=nav-item><a href=/C++17/direct-list-initialization-of-enumerations/>枚举直接列表初始化</a><li class=nav-item><a href=/C++17/dynamic-memory-allocation-for-over-aligned-data/>为过量对齐数据动态分配内存</a><li class=nav-item><a href=/C++17/elementary-string-convertions/>基础字符串转换</a><li class=nav-item><a href=/C++17/fold-expressions/>折叠表达式</a><li class=nav-item><a href=/C++17/guaranteed-copy-elision/>保证复制省略</a><li class=nav-item><a href=/C++17/hexadecimal-floating-point-literals/>16进制浮点字面量</a><li class=nav-item><a href=/C++17/ignore-unknown-attributes/>忽略未知属性</a><li class=nav-item><a href=/C++17/improving-std-pair-and-std-tuple/>改进std::pair和std::tuple</a><li class=nav-item><a href=/C++17/init-statements-for-if-and-switch/>if和switch的初始化语句</a><li class=nav-item><a href=/C++17/inline-variables/>Inline变量</a><li class=nav-item><a href=/C++17/lambda-capture-of-star-this/>Lambda表达式可以捕获*this</a><li class=nav-item><a href=/C++17/make-exception-specifications-part-of-the-type-system/>将异常规范作为类型系统的一部分</a><li class=nav-item><a href=/C++17/matching-of-template-template-arguments-excludes-compatible-templates/>匹配排除兼容模板后的模板模板参数</a><li class=nav-item><a href=/C++17/nested-namespace-definition/>嵌套名字空间定义</a><li class=nav-item><a href=/C++17/new-auto-rules-for-direct-list-initialization/>为直接列表初始化设置新的auto规则</a><li class=nav-item><a href=/C++17/new-specification-for-inheriting-constructors/>继承构造函数的新规范</a><li class=nav-item><a href=/C++17/non-type-template-parameters-with-auto-type/>用auto类型作为无类型的模板参数</a><li class=nav-item><a href=/C++17/pack-expansions-in-using-declarations/>在using声明中使用打包扩张(pack expansion)</a><li class=nav-item><a href=/C++17/remove-deprecated-exception-specifications-from-C++17/>删除C++17中废弃的异常规范</a><li class=nav-item><a href=/C++17/remove-deprecated-operator++(bool)/>删除废弃的operator++(bool)</a><li class=nav-item><a href=/C++17/remove-deprecated-use-of-the-register-keyword/>删除废弃的register关键字</a><li class=nav-item><a href=/C++17/removing-trigraphs/>删除三联符</a><li class=nav-item><a href=/C++17/splicing-maps-and-sets/>拼接map和set</a><li class=nav-item><a href=/C++17/standardization-of-parallelism-ts/>并行的技术规范标准化</a><li class=nav-item><a href=/C++17/static_assert-with-no-message/>无消息的静态断言</a><li class=nav-item><a href=/C++17/std-shared_mutex(untimed)/>std::shared_mutex（untimed）</a><li class=nav-item><a href=/C++17/std-string_view/>std::string_view</a><li class=nav-item><a href=/C++17/std-uncaught_exceptions/>std::uncaught_exceptions</a><li class=nav-item><a href=/C++17/stricter-expression-evaluation-order/>更严格的表达式估值顺序</a><li class=nav-item><a href=/C++17/structured-bindings/>结构化绑定</a><li class=nav-item><a href=/C++17/template-argument-deduction-for-class-template/>类模板的模板参数推导</a><li class=nav-item><a href=/C++17/typename-in-a-template-template-parameter/>模板模板参数中使用typename</a><li class=nav-item><a href=/C++17/u8-character-literals/>u8字符字面量</a><li class=nav-item><a href=/C++17/unary-fold-expressions-and-empty-parameter-pack/>一元折叠表达式和空参打包</a><li class=nav-item><a href=/C++17/using-attribute-namespaces-without-repetition/>不重复地使用带属性的名字空间</a></ul></ul><ul><li class="nav-item top-level"><a href=/changelog/>更新日志</a></ul></nav></header><section class=main><div class=page-header><h2>C++11</h2><h3>Lambda表达式</h3></div><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-3435940217424489 data-ad-slot=9166587836 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><article class=content><blockquote><p>编译器支持最低版本要求:<ul><li>GCC: 4.5(v1.1)<li>MSVC: 16.0<li>Clang: 3.1</ul><p>提案: v0.9 - <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf>N2550</a>/v1.0 - <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2658.pdf>N2658</a>/v1.1 - <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf>N2927</a></blockquote><p>Lambda表达式就是匿名函数，在C++11之前Boost凭借C++语言强大的template和预处理宏，以及库作者强悍的奇技淫巧实现了<a href=http://www.boost.org/doc/libs/1_65_0/doc/html/lambda.html>Boost.lambda</a>和更高级用法<a href=http://www.boost.org/doc/libs/1_65_0/libs/phoenix/>Boost.phoenix</a>，但没有语言层面的支持，完全用库实现不但稍显累赘，而且代码观感不佳。C++11在语言层面实现了lambda，语法定义如下：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>[</span><span class=n>capture</span><span class=p>](</span><span class=n>parameters</span><span class=p>)</span><span class=k>mutable</span> <span class=o>-&gt;</span> <span class=k>return</span><span class=o>-</span><span class=n>value</span> <span class=p>{</span> <span class=n>statement</span> <span class=p>}</span>
</code></pre></div></div><ul><li><code class=highlighter-rouge>[capture]</code>：捕捉列表，可以捕捉上下文中的变量以供lambda表达式使用。<li><code class=highlighter-rouge>(parameters)</code>：参数列表，同普通函数相同的参数列表定义，如果没有参数，可以留空括号<code class=highlighter-rouge>()</code>，甚至连空括号都省略。在C++11中lambda参数类型不能自动推导，即不能为auto，在<a href=../../C++14/generic-plymorphic-lambda/>C++14中已经支持</a>。<li><code class=highlighter-rouge>mutable</code>：默认情况下lambda表达式是一个<code class=highlighter-rouge>const</code>函数，但可以显式指定<code class=highlighter-rouge>mutable</code>取消其常量性，这时不能省略空参数列表的空括号<code class=highlighter-rouge>()</code>。<li><code class=highlighter-rouge>-> return-value</code>：返回类型，如果没有返回类型（即<code class=highlighter-rouge>void</code>），可以全部省略。如果返回类型明确，也可以省略，让编译器进行自动类型推导。<li><code class=highlighter-rouge>{ statement }</code>：函数体，跟普通函数相同的用法。</ul><p>所以一个最简单的lambda表达式是这样的：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>[]{}</span>
</code></pre></div></div><p>尽管它什么事都没干，也没什么作用，但确实是一个合法的lambda表达式。<p>捕捉列表可以有0个，或1个，或多个捕捉项，以逗号分隔，可以有以下几种形式：<ol><li><code class=highlighter-rouge>[var]</code>，表示值传递方式捕捉变量<code class=highlighter-rouge>var</code>。<li><code class=highlighter-rouge>[&amp;var]</code>，表示引用传递方式捕捉变量<code class=highlighter-rouge>var</code>。<li><code class=highlighter-rouge>[=]</code>，表示值传递方式捕捉所有父作用域的变量。<li><code class=highlighter-rouge>[&]</code>，表示引用传递方式捕捉所有父作用域的变量。<li><code class=highlighter-rouge>[this]</code>，表示捕捉当前<code class=highlighter-rouge>this</code>指针，但不能捕捉<code class=highlighter-rouge>*this</code>，但<a href=../../C++17/lambda-capture-of-star-this/>在C++17中已经可以捕捉</a>。<code class=highlighter-rouge>this</code>也包括在<code class=highlighter-rouge>[=]</code>和<code class=highlighter-rouge>[&]</code>中。</ol><p>然后可以多个捕捉项组合：<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>[=, &amp;a, &amp;b]
[&amp;, a, b]
</code></pre></div></div><p>但是多个捕捉项不能重复：<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>[a, a]
[=, a]
[&amp;, &amp;a]
</code></pre></div></div><p>捕捉列表的不同，效果也会不同：<ul><li>按值传递的捕捉项在lambda表达式被定义时就已经决定。<li>按引用传递的捕捉项在lambda表达式被调用时决定。<li>按值传递的捕捉变量不能被lambda表达式内修改，按引用传递的可以。<li>从代码生成角度看，如果是内建数据类型（int，short，long之类的）如果以引用传递方式会比以值传递方式多一条获取变量地址的指令。</ul><p>Lambda表达式在功能上跟仿函数（functor，也称函数对象，function object）非常相似：可以保存外部变量的状态，可以传入参数，可以被调用。编译器在实现lambda表达式时也采用了与仿函数相似的方法。<p>每个lambda表达式都有自己特有的类型，也就是说不能仅仅因为捕捉列表、参数列表、返回值类型相同而把一个lambda表达式赋给另一个保存着lambda表达式的变量，却可以把一个保存了lambda表达式的变量赋给另一个变量：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>auto</span> <span class=n>f</span> <span class=o>=</span> <span class=p>[](</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span><span class=o>-&gt;</span><span class=kt>int</span> <span class=p>{</span> <span class=k>return</span> <span class=n>n</span><span class=p>;};</span>
<span class=k>decltype</span><span class=p>(</span><span class=n>f</span><span class=p>)</span> <span class=n>f2</span> <span class=o>=</span> <span class=n>f</span><span class=p>;</span> <span class=c1>// 正确</span>
<span class=k>decltype</span><span class=p>(</span><span class=n>f</span><span class=p>)</span> <span class=n>f3</span> <span class=o>=</span> <span class=p>[](</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span><span class=o>-&gt;</span><span class=kt>int</span> <span class=p>{</span> <span class=k>return</span> <span class=n>n</span><span class=p>;};</span>  <span class=c1>// 编译错误</span>
</code></pre></div></div><p>Lambda表达式在C++中最典型的应用场景是作为被回调体，比如STL诸多算法需要提供谓词（predicate），简短的lambda比函数指针和仿函数都要更适合承担这份工作：<ul><li>有机会被内联优化，函数指针不行。<li>就地定义、就地使用，短小、分散的仿函数破坏程序整体结构。</ul><p>但是lambda表达式并不能完全取代仿函数：<ul><li>函数体较大时，使用仿函数更能理清程序结构。<li>捕捉变量范围有限，仅在父作用域范围，尽管有的编译器（GCC可以捕捉到全局变量等）自行扩展了范围，但并不合标准定义。</ul><h4 id=相关链接>相关链接</h4><ul><li><a href=../../C++17/lambda-capture-of-star-this/>Lambda表达式可以捕获*this</a><li><a href=../../C++14/generic-plymorphic-lambda/>Lambda表达式的泛型和多态</a></ul></article><div class=content><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div style=line-height:2.5>感觉不错，小额赞助一下！</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>打赏</span></button><div id=QR style=display:block><div id=wechat style=display:inline-block><a href=wxp://f2f0JOwB8LU7CU53fcitPGIuC6lYMX1q-nlk class=fancybox rel=group><img id=wechat_qr src=https://blogassets.ismisv.com/assets/images/wepay.jpg alt="missdeer WeChat Pay"></a><p>微信扫一扫</div><div id=wechat style=display:inline-block><a href="alipays://platformapi/startapp?appId=10000007&qrcode=https://qr.alipay.com/tsx00458kzwvymgbjk0ci9e" class=fancybox rel=group><img id=alipay_qr src=https://blogassets.ismisv.com/assets/images/alipay.jpg alt="missdeer AliPay"></a><p>支付宝扫一扫</div></div></div></div><div class=content></hr><div style=color:#b3b3b3;font-size:.7em><p>Hosted by <a href=https://app.netlify.com/ style=font-weight:700>Netlify</a>,
本站由 <a href=https://minidump.info target=_blank>@missdeer</a> 创建，由 <a href=https://jekyllrb.com target=_blank>Jekyll</a> 于 2024-11-07 生成，感谢<a href=https://github.com/CloudCannon target=_blank> CloudCannon </a>制作的theme： <a href=https://github.com/CloudCannon/edition-jekyll-template target=_blank>Edition</a> ，感谢<a href=https://letsencrypt.org/ target=_blank> Let's Encrypt </a>提供免费的SSL证书服务。本站点采用<a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>知识共享署名-非商业性使用-相同方式共享
4.0 国际许可协议</a>进行许可。&copy; 2017 - 2024</div></div></section><script>document.getElementById("open-nav").addEventListener("click",function(){document.body.classList.toggle("nav-open")})</script>