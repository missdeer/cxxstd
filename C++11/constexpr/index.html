<!doctype html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Jekyll v3.8.6"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700"><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/css/main.min.css><link rel=stylesheet href=https://blogassets.ismisv.com/css/pay.min.css><link rel=apple-touch-icon href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/apple-touch-icon.png><link rel=icon type=image/png href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/touch-icon.png sizes=192x192><link rel=icon type=image/png href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/images/favicon.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css media=print onload='this.media="all"'><style>body{font-family:lxgw wenkai screen,sans-serif}</style><link type=application/atom+xml rel=alternate href=https://minidump.info/feed.xml title="不那么新的modern C++简要学习笔记"><title>常量表达式 - 不那么新的modern C++简要学习笔记</title><meta property="og:title" content="常量表达式"><meta name=description content="  编译器支持最低版本要求:      GCC: 4.6    MSVC: 19.0    Clang: 3.1    提案: N2235"><meta property="og:description" content="  编译器支持最低版本要求:      GCC: 4.6    MSVC: 19.0    Clang: 3.1    提案: N2235"><link rel=canonical href=https://minidump.info/C++11/constexpr/><meta property="og:url" content="https://minidump.info/C++11/constexpr/"><meta property="og:site_name" content="不那么新的modern C++简要学习笔记"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"常量表达式","description":"  编译器支持最低版本要求:      GCC: 4.6    MSVC: 19.0    Clang: 3.1    提案: N2235","logo":"https://minidump.info/siteicon.png","url":"https://minidump.info/C++11/constexpr/"}</script><script>(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-52744860-1","auto"),ga("send","pageview")</script><header><h1><a href=/><img src=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/images/emblem.svg width=40 height=40 alt="不那么新的modern C++简要学习笔记 logo"></a>
不那么新的modern C++简要学习笔记
<button type=button class=open-nav id=open-nav></button></h1><form action=/search/><input name=q id=search-input placeholder=Search autofocus>
<input type=submit value=Search style=display:none></form><nav class=full-navigation><ul><li class="nav-item top-level"><a href=/>前言</a></ul><ul><li class="nav-item top-level current"><a href=/C++11/alignas/>C++11</a><ul><li class=nav-item><a href=/C++11/alignas/>Alignas</a><li class=nav-item><a href=/C++11/alignof/>Alignof</a><li class=nav-item><a href=/C++11/atomic-operations/>原子操作</a><li class=nav-item><a href=/C++11/attributes/>属性</a><li class=nav-item><a href=/C++11/auto/>自动类型推导</a><li class=nav-item><a href=/C++11/c99-preprocessor/>C99兼容预处理器</a><li class="nav-item current"><a href=/C++11/constexpr/>常量表达式</a><li class=nav-item><a href=/C++11/decltype/>decltype</a><li class=nav-item><a href=/C++11/defaulted-and-deleted-functions/>缺省函数和可删除函数</a><li class=nav-item><a href=/C++11/delegating-constructors/>委托构造函数</a><li class=nav-item><a href=/C++11/dynamic-initialization-and-destruction-with-concurrency/>动态初始化和并发析构（魔法静态）</a><li class=nav-item><a href=/C++11/dynamic-pointer-safety/>动态指针安全（垃圾回收接口）</a><li class=nav-item><a href=/C++11/explicit-conversion-operators/>显式转换操作符</a><li class=nav-item><a href=/C++11/extended-friend-declarations/>扩展的friend声明</a><li class=nav-item><a href=/C++11/extern-template/>外部模板</a><li class=nav-item><a href=/C++11/forward-enum-declarations/>前向声明枚举类型</a><li class=nav-item><a href=/C++11/inheriting-constructors/>继承构造函数</a><li class=nav-item><a href=/C++11/initializer-lists/>初始化列表</a><li class=nav-item><a href=/C++11/inline-namespace/>内联名字空间</a><li class=nav-item><a href=/C++11/lambda/>Lambda表达式</a><li class=nav-item><a href=/C++11/local-and-unnamed-types-as-template-parameters/>本地和匿名类型作为模板参数</a><li class=nav-item><a href=/C++11/long-long/>long long类型</a><li class=nav-item><a href=/C++11/money-time-hexfloat-IO-manipulators/>货币、时间、16进制浮点I/O操作</a><li class=nav-item><a href=/C++11/new-characger-type/>新字符类型</a><li class=nav-item><a href=/C++11/noexcept/>noexcept关键字</a><li class=nav-item><a href=/C++11/non-static-data-member-initializers/>非静态数据成员初始化</a><li class=nav-item><a href=/C++11/nullptr/>Nullptr</a><li class=nav-item><a href=/C++11/override-and-final/>override和final关键字</a><li class=nav-item><a href=/C++11/range-for-loop/>基于范围的for循环</a><li class=nav-item><a href=/C++11/raw-string-literals/>原始字面量字符串</a><li class=nav-item><a href=/C++11/ref-qualifiers/>扩展移动语义</a><li class=nav-item><a href=/C++11/right-angle-brackets/>右尖括号</a><li class=nav-item><a href=/C++11/rvalue-ref/>右值引用</a><li class=nav-item><a href=/C++11/static-assert/>静态断言</a><li class=nav-item><a href=/C++11/strongly-typed-enum/>强类型枚举</a><li class=nav-item><a href=/C++11/template-aliases/>模板别名</a><li class=nav-item><a href=/C++11/thread-local-storage/>线程本地存储</a><li class=nav-item><a href=/C++11/trailing-function-return-types/>过滤函数返回类型</a><li class=nav-item><a href=/C++11/type-traits/>类型萃取</a><li class=nav-item><a href=/C++11/unicode-string-literals/>Unicode字面量字符串</a><li class=nav-item><a href=/C++11/unrestricted-unions/>非受限联合体</a><li class=nav-item><a href=/C++11/user-defined-literals/>用户自定义字面量</a><li class=nav-item><a href=/C++11/variadic-templates/>可变参数模板</a></ul><li class="nav-item top-level"><a href=/C++14/binary-literals/>C++14</a><ul><li class=nav-item><a href=/C++14/binary-literals/>二进制字面量</a><li class=nav-item><a href=/C++14/clarifying-memory-allocation/>澄清内存分配</a><li class=nav-item><a href=/C++14/constexpr-for-array/>&lt;array>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-chrono/>&lt;chrono>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-complex/>&lt;complex>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-initializer_list-utility-and-tuple/>&lt;initializer_list>，&lt;utility>和&lt;tuple>的常量表达式</a><li class=nav-item><a href=/C++14/decltype(auto)-return-type-deduction-for-normal-functions/>普通函数返回值类型推导</a><li class=nav-item><a href=/C++14/deprecated-attribute/>废弃的属性</a><li class=nav-item><a href=/C++14/dual-range-std-equal-std-is_permutation-std-mismatch/>双范围的std::equal, std::is_permutation, std::mismatch</a><li class=nav-item><a href=/C++14/extended-constexpr/>扩展常量表达式</a><li class=nav-item><a href=/C++14/fixing-constexpr-member-function-without-const/>修复成员函数常量表达式不能带const修饰</a><li class=nav-item><a href=/C++14/generic-plymorphic-lambda/>Lambda表达式的泛型和多态</a><li class=nav-item><a href=/C++14/heterogeneous-associative-lookup/>关联容器异构比较查找算法</a><li class=nav-item><a href=/C++14/improved-std-integral_constant/>改进std::integral_constant</a><li class=nav-item><a href=/C++14/initialized-generalized-lambda-captures/>初始化和泛化lambda表达式捕获列表</a><li class=nav-item><a href=/C++14/member-initializers-and-aggregates/>成员初始化和聚合</a><li class=nav-item><a href=/C++14/null-forward-iterators/>Null前向迭代器</a><li class=nav-item><a href=/C++14/single-quote-as-digit-separator/>单引号作为数字分隔符</a><li class=nav-item><a href=/C++14/sized-deallocation/>释放指定大小的内存</a><li class=nav-item><a href=/C++14/std-exchange/>std::exchage</a><li class=nav-item><a href=/C++14/std-get_T/>std::get&lt;T>()</a><li class=nav-item><a href=/C++14/std-integer_squence/>std::integer_squence</a><li class=nav-item><a href=/C++14/std-quoted/>std::quoted</a><li class=nav-item><a href=/C++14/std-result_of-and-SFINAE/>std::result_of和SFINAE</a><li class=nav-item><a href=/C++14/std-shared_timed_mutex/>std::shared_timed_mutex</a><li class=nav-item><a href=/C++14/tweaked-wording-for-contextual-conversions/>调整上下文转换</a><li class=nav-item><a href=/C++14/user-defined-literals-for-chrono-and-string/>为chrono和string提供用户自定义字面量</a><li class=nav-item><a href=/C++14/variable-templates/>变量模板</a></ul><li class="nav-item top-level"><a href=/C++17/%5B%5Bfallthrough%5D%5D-attribute/>C++17</a><ul><li class=nav-item><a href=/C++17/%5B%5Bfallthrough%5D%5D-attribute/>[[fallthrough]]属性</a><li class=nav-item><a href=/C++17/%5B%5Bmaybe_unused%5D%5D-attribute/>[[maybe_unused]]属性</a><li class=nav-item><a href=/C++17/%5B%5Bnodiscard%5D%5D-attribute/>[[nodiscard]]属性</a><li class=nav-item><a href=/C++17/aggregate-initialization-of-class-with-base-classes/>聚合带基类的类的初始化</a><li class=nav-item><a href=/C++17/allow-constant-evaluation-for-all-non-type-template-arguments/>允许所有非类型模板参数进行参量计算</a><li class=nav-item><a href=/C++17/attributes-for-namespaces-and-enumerators/>名字空间和枚举的属性</a><li class=nav-item><a href=/C++17/constexpr-if-statements/>if语句常量表达式</a><li class=nav-item><a href=/C++17/constexpr-lambda-expressions/>Lambda常量表达式</a><li class=nav-item><a href=/C++17/differing-begin-and-end-types-in-range-based-for/>基于范围的for循环可以拥有不同类型的begin和end</a><li class=nav-item><a href=/C++17/direct-list-initialization-of-enumerations/>枚举直接列表初始化</a><li class=nav-item><a href=/C++17/dynamic-memory-allocation-for-over-aligned-data/>为过量对齐数据动态分配内存</a><li class=nav-item><a href=/C++17/elementary-string-convertions/>基础字符串转换</a><li class=nav-item><a href=/C++17/fold-expressions/>折叠表达式</a><li class=nav-item><a href=/C++17/guaranteed-copy-elision/>保证复制省略</a><li class=nav-item><a href=/C++17/hexadecimal-floating-point-literals/>16进制浮点字面量</a><li class=nav-item><a href=/C++17/ignore-unknown-attributes/>忽略未知属性</a><li class=nav-item><a href=/C++17/improving-std-pair-and-std-tuple/>改进std::pair和std::tuple</a><li class=nav-item><a href=/C++17/init-statements-for-if-and-switch/>if和switch的初始化语句</a><li class=nav-item><a href=/C++17/inline-variables/>Inline变量</a><li class=nav-item><a href=/C++17/lambda-capture-of-star-this/>Lambda表达式可以捕获*this</a><li class=nav-item><a href=/C++17/make-exception-specifications-part-of-the-type-system/>将异常规范作为类型系统的一部分</a><li class=nav-item><a href=/C++17/matching-of-template-template-arguments-excludes-compatible-templates/>匹配排除兼容模板后的模板模板参数</a><li class=nav-item><a href=/C++17/nested-namespace-definition/>嵌套名字空间定义</a><li class=nav-item><a href=/C++17/new-auto-rules-for-direct-list-initialization/>为直接列表初始化设置新的auto规则</a><li class=nav-item><a href=/C++17/new-specification-for-inheriting-constructors/>继承构造函数的新规范</a><li class=nav-item><a href=/C++17/non-type-template-parameters-with-auto-type/>用auto类型作为无类型的模板参数</a><li class=nav-item><a href=/C++17/pack-expansions-in-using-declarations/>在using声明中使用打包扩张(pack expansion)</a><li class=nav-item><a href=/C++17/remove-deprecated-exception-specifications-from-C++17/>删除C++17中废弃的异常规范</a><li class=nav-item><a href=/C++17/remove-deprecated-operator++(bool)/>删除废弃的operator++(bool)</a><li class=nav-item><a href=/C++17/remove-deprecated-use-of-the-register-keyword/>删除废弃的register关键字</a><li class=nav-item><a href=/C++17/removing-trigraphs/>删除三联符</a><li class=nav-item><a href=/C++17/splicing-maps-and-sets/>拼接map和set</a><li class=nav-item><a href=/C++17/standardization-of-parallelism-ts/>并行的技术规范标准化</a><li class=nav-item><a href=/C++17/static_assert-with-no-message/>无消息的静态断言</a><li class=nav-item><a href=/C++17/std-shared_mutex(untimed)/>std::shared_mutex（untimed）</a><li class=nav-item><a href=/C++17/std-string_view/>std::string_view</a><li class=nav-item><a href=/C++17/std-uncaught_exceptions/>std::uncaught_exceptions</a><li class=nav-item><a href=/C++17/stricter-expression-evaluation-order/>更严格的表达式估值顺序</a><li class=nav-item><a href=/C++17/structured-bindings/>结构化绑定</a><li class=nav-item><a href=/C++17/template-argument-deduction-for-class-template/>类模板的模板参数推导</a><li class=nav-item><a href=/C++17/typename-in-a-template-template-parameter/>模板模板参数中使用typename</a><li class=nav-item><a href=/C++17/u8-character-literals/>u8字符字面量</a><li class=nav-item><a href=/C++17/unary-fold-expressions-and-empty-parameter-pack/>一元折叠表达式和空参打包</a><li class=nav-item><a href=/C++17/using-attribute-namespaces-without-repetition/>不重复地使用带属性的名字空间</a></ul></ul><ul><li class="nav-item top-level"><a href=/changelog/>更新日志</a></ul></nav></header><section class=main><div class=page-header><h2>C++11</h2><h3>常量表达式</h3></div><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-3435940217424489 data-ad-slot=9166587836 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><article class=content><blockquote><p>编译器支持最低版本要求:<ul><li>GCC: 4.6<li>MSVC: 19.0<li>Clang: 3.1</ul><p>提案: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf>N2235</a></blockquote><h2 id=背景>背景</h2><p>在C++11之前，程序中的常量表达式主要依赖于宏定义和const变量。但这些方式都存在一些局限性：<ul><li>宏定义不具备类型安全性，且容易导致代码可维护性降低<li>const变量虽然不可修改，但并不保证在编译期可计算<li>一些需要编译期常量的场景（如数组大小、模板参数等）无法使用更灵活的表达式</ul><p>为了解决这些问题，C++11引入了constexpr关键字，用于声明可以在编译期计算的常量表达式。<h2 id=基本用法>基本用法</h2><h3 id=constexpr变量>constexpr变量</h3><p>constexpr变量必须用常量表达式初始化：<div class="language-cpp highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span> <span class=c1>// OK</span>
<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>double_size</span> <span class=o>=</span> <span class=n>size</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>// OK</span>
<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>random</span> <span class=o>=</span> <span class=n>rand</span><span class=p>();</span> <span class=c1>// 错误：rand()不是常量表达式</span>
</code></pre></div></div><h3 id=constexpr函数>constexpr函数</h3><p>constexpr函数在编译期可计算，但也可以在运行时使用：<div class="language-cpp highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>square</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>x</span> <span class=n>x</span><span class=p>;</span>
<span class=p>}</span>
<span class=c1>// 编译期计算</span>
<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>sq_5</span> <span class=o>=</span> <span class=n>square</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span> <span class=c1>// sq_5 = 25，编译期确定</span>
<span class=c1>// 运行时计算</span>
<span class=kt>int</span> <span class=n>some_value</span> <span class=o>=</span> <span class=n>get_value</span><span class=p>();</span>
<span class=kt>int</span> <span class=n>sq_val</span> <span class=o>=</span> <span class=n>square</span><span class=p>(</span><span class=n>some_value</span><span class=p>);</span> <span class=c1>// 运行时计算</span>
</code></pre></div></div><h2 id=使用场景>使用场景</h2><h3 id=1-数组维度声明>1. 数组维度声明</h3><div class="language-cpp highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>get_array_size</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>42</span><span class=p>;</span> <span class=p>}</span>
<span class=kt>int</span> <span class=n>array</span><span class=p>[</span><span class=n>get_array_size</span><span class=p>()];</span> <span class=c1>// OK，编译期可确定大小</span>
</code></pre></div></div><h3 id=2-模板参数>2. 模板参数</h3><div class="language-cpp highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>template</span><span class=o>&lt;</span><span class=kt>int</span> <span class=n>N</span><span class=o>&gt;</span>
<span class=k>struct</span> <span class=n>Array</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>data</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
<span class=p>};</span>
<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
<span class=n>Array</span><span class=o>&lt;</span><span class=n>square</span><span class=p>(</span><span class=n>size</span><span class=p>)</span><span class=o>&gt;</span> <span class=n>arr</span><span class=p>;</span> <span class=c1>// OK，square(size)在编译期计算</span>
</code></pre></div></div><h3 id=3-编译期计算提升性能>3. 编译期计算提升性能</h3><div class="language-cpp highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=o>?</span> <span class=n>n</span> <span class=o>:</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>);</span>
<span class=p>}</span>
<span class=c1>// 编译期就计算出结果</span>
<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>fib_10</span> <span class=o>=</span> <span class=n>fibonacci</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</code></pre></div></div><h2 id=限制条件>限制条件</h2><p>C++11中的constexpr函数有较多限制：<ul><li>函数体只能包含一条return语句<li>只能调用其他constexpr函数<li>不能包含循环或分支语句<li>不能有副作用（如修改静态或全局变量）</ul><p>注意：这些限制在C++14中得到了很大放松。<h2 id=最佳实践>最佳实践</h2><ol><li>当需要编译期常量时，优先使用constexpr而不是宏定义<li>设计编译期可计算的函数时，尽量使用constexpr声明<li>constexpr函数应保持简单，避免复杂的逻辑<li>记住constexpr函数可以在运行时使用，这提供了很好的灵活性</ol><h2 id=与其他特性的对比>与其他特性的对比</h2><h3 id=constexpr-vs-const>constexpr vs const</h3><ol><li>计算时机<ul><li>const：仅表示运行时常量，不可修改<li>constexpr：表示编译期常量，编译器会在编译期计算其值</ul><li>使用场景</ol><div class="language-cpp highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>// const示例</span>
<span class=k>const</span> <span class=kt>int</span> <span class=n>val1</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span> <span class=c1>// OK</span>
<span class=k>const</span> <span class=kt>int</span> <span class=n>val2</span> <span class=o>=</span> <span class=n>get_value</span><span class=p>();</span> <span class=c1>// OK，运行时初始化</span>
<span class=kt>int</span> <span class=n>arr1</span><span class=p>[</span><span class=n>val1</span><span class=p>];</span> <span class=c1>// 错误：数组大小需要编译期常量</span>
<span class=kt>int</span> <span class=n>arr2</span><span class=p>[</span><span class=n>val2</span><span class=p>];</span> <span class=c1>// 错误：数组大小需要编译期常量</span>
<span class=c1>// constexpr示例</span>
<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>val3</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span> <span class=c1>// OK</span>
<span class=k>constexpr</span> <span class=kt>int</span> <span class=n>val4</span> <span class=o>=</span> <span class=n>get_value</span><span class=p>();</span> <span class=c1>// 错误：需要编译期常量表达式</span>
<span class=kt>int</span> <span class=n>arr3</span><span class=p>[</span><span class=n>val3</span><span class=p>];</span> <span class=c1>// OK，val3是编译期常量</span>
</code></pre></div></div><ol><li>函数声明</ol><div class="language-cpp highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>// const成员函数：表示不会修改对象状态</span>
<span class=k>class</span> <span class=nc>MyClass</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>
    <span class=nl>public:</span>
    <span class=kt>int</span> <span class=n>getValue</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>value</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// 运行时执行</span>
<span class=p>};</span>
<span class=c1>// constexpr函数：可在编译期执行</span>
<span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>square</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// 编译期执行</span>
</code></pre></div></div><ol><li>主要区别总结：<ul><li>const主要用于：<ul><li>声明运行时不可修改的变量<li>声明不修改对象状态的成员函数<li>声明指向常量的指针或引用</ul></ul></ol><ul><li>constexpr主要用于：<ul><li>声明编译期可计算的常量<li>声明编译期可执行的函数<li>用在需要编译期常量的场景（如数组大小、模板参数等）</ul></ul><h3 id=constexpr-vs-define>constexpr vs #define</h3><ol><li>类型安全性</ol><div class="language-cpp highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=cp>#define MAX_SIZE 100 // 无类型检查
</span><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>MaxSize</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span> <span class=c1>// 有类型检查</span>
<span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>short</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
    <span class=cp>#define SQUARE(x) ((x) (x))
</span>    <span class=kt>short</span> <span class=n>s1</span> <span class=o>=</span> <span class=n>SQUARE</span><span class=p>(</span><span class=n>s</span><span class=p>);</span> <span class=c1>// 可能溢出，无警告</span>
    <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>square</span> <span class=o>=</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>x</span> <span class=n>x</span><span class=p>;</span>
    <span class=p>};</span>
    <span class=kt>short</span> <span class=n>s2</span> <span class=o>=</span> <span class=n>square</span><span class=p>(</span><span class=n>s</span><span class=p>);</span> <span class=c1>// 编译器会进行类型检查</span>
<span class=p>}</span>
</code></pre></div></div><ol><li>作用域<ul><li>#define：无作用域概念，全局生效<li>constexpr：遵循正常的作用域规则</ul><li>调试友好性<ul><li>#define：预处理阶段处理，调试时看不到原始值<li>constexpr：是正常的变量和函数，调试时可以看到具体值</ul><li>主要优势对比：</ol><ul><li>#define：<ul><li>简单的文本替换<li>可用于条件编译<li>预处理阶段处理</ul><li>constexpr：<ul><li>类型安全<li>支持作用域<li>可以使用复杂表达式<li>调试友好<li>支持函数和类成员</ul></ul><h2 id=使用建议>使用建议</h2><ol><li>优先级顺序：<ul><li>需要编译期常量时：首选constexpr<li>仅需要运行时常量时：使用const<li>仅在确实需要预处理器功能时：使用#define</ul><li>场景选择：<ul><li>模板参数：使用constexpr<li>数组大小：使用constexpr<li>运行时只读变量：使用const<li>条件编译：使用#define</ul></ol><h2 id=总结>总结</h2><p>constexpr是C++11引入的重要特性，它为编译期计算提供了类型安全和更好的可维护性。通过合理使用constexpr，我们可以：<ul><li>在编译期进行更多计算，提升运行时性能<li>实现更灵活的编译期常量表达式<li>保证类型安全性<li>提高代码的可维护性</ul><p>随着C++14、C++17的发展，constexpr的功能更加强大，使用场景也更加广泛。</article><div class=content><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div style=line-height:2.5>感觉不错，小额赞助一下！</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>打赏</span></button><div id=QR style=display:block><div id=wechat style=display:inline-block><a href=wxp://f2f0JOwB8LU7CU53fcitPGIuC6lYMX1q-nlk class=fancybox rel=group><img id=wechat_qr src=https://blogassets.ismisv.com/assets/images/wepay.jpg alt="missdeer WeChat Pay"></a><p>微信扫一扫</div><div id=wechat style=display:inline-block><a href="alipays://platformapi/startapp?appId=10000007&qrcode=https://qr.alipay.com/tsx00458kzwvymgbjk0ci9e" class=fancybox rel=group><img id=alipay_qr src=https://blogassets.ismisv.com/assets/images/alipay.jpg alt="missdeer AliPay"></a><p>支付宝扫一扫</div></div></div></div><div class=content></hr><div style=color:#b3b3b3;font-size:.7em><p>Hosted by <a href=https://app.netlify.com/ style=font-weight:700>Netlify</a>,
本站由 <a href=https://minidump.info target=_blank>@missdeer</a> 创建，由 <a href=https://jekyllrb.com target=_blank>Jekyll</a> 于 2024-11-07 生成，感谢<a href=https://github.com/CloudCannon target=_blank> CloudCannon </a>制作的theme： <a href=https://github.com/CloudCannon/edition-jekyll-template target=_blank>Edition</a> ，感谢<a href=https://letsencrypt.org/ target=_blank> Let's Encrypt </a>提供免费的SSL证书服务。本站点采用<a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>知识共享署名-非商业性使用-相同方式共享
4.0 国际许可协议</a>进行许可。&copy; 2017 - 2024</div></div></section><script>document.getElementById("open-nav").addEventListener("click",function(){document.body.classList.toggle("nav-open")})</script>