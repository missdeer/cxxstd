<!doctype html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Jekyll v3.8.6"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700"><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/css/main.min.css><link rel=stylesheet href=https://blogassets.ismisv.com/css/pay.min.css><link rel=apple-touch-icon href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/apple-touch-icon.png><link rel=icon type=image/png href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/touch-icon.png sizes=192x192><link rel=icon type=image/png href=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/images/favicon.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css media=print onload='this.media="all"'><style>body{font-family:lxgw wenkai screen,sans-serif}</style><link type=application/atom+xml rel=alternate href=https://minidump.info/feed.xml title="不那么新的modern C++简要学习笔记"><title>C99兼容预处理器 - 不那么新的modern C++简要学习笔记</title><meta property="og:title" content="C99兼容预处理器"><meta name=description content="  编译器支持最低版本要求:      GCC: 4.3    MSVC: 19.0    Clang: Yes    提案: N1653"><meta property="og:description" content="  编译器支持最低版本要求:      GCC: 4.3    MSVC: 19.0    Clang: Yes    提案: N1653"><link rel=canonical href=https://minidump.info/C++11/c99-preprocessor/><meta property="og:url" content="https://minidump.info/C++11/c99-preprocessor/"><meta property="og:site_name" content="不那么新的modern C++简要学习笔记"><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"C99兼容预处理器","description":"  编译器支持最低版本要求:      GCC: 4.3    MSVC: 19.0    Clang: Yes    提案: N1653","logo":"https://minidump.info/siteicon.png","url":"https://minidump.info/C++11/c99-preprocessor/"}</script><script>(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-52744860-1","auto"),ga("send","pageview")</script><header><h1><a href=/><img src=https://cdn.jsdelivr.net/gh/missdeer/cxxstd@gh-pages/images/emblem.svg width=40 height=40 alt="不那么新的modern C++简要学习笔记 logo"></a>
不那么新的modern C++简要学习笔记
<button type=button class=open-nav id=open-nav></button></h1><form action=/search/><input name=q id=search-input placeholder=Search autofocus>
<input type=submit value=Search style=display:none></form><nav class=full-navigation><ul><li class="nav-item top-level"><a href=/>前言</a></ul><ul><li class="nav-item top-level current"><a href=/C++11/alignas/>C++11</a><ul><li class=nav-item><a href=/C++11/alignas/>Alignas</a><li class=nav-item><a href=/C++11/alignof/>Alignof</a><li class=nav-item><a href=/C++11/atomic-operations/>原子操作</a><li class=nav-item><a href=/C++11/attributes/>属性</a><li class=nav-item><a href=/C++11/auto/>自动类型推导</a><li class="nav-item current"><a href=/C++11/c99-preprocessor/>C99兼容预处理器</a><li class=nav-item><a href=/C++11/constexpr/>常量表达式</a><li class=nav-item><a href=/C++11/decltype/>decltype</a><li class=nav-item><a href=/C++11/defaulted-and-deleted-functions/>缺省函数和可删除函数</a><li class=nav-item><a href=/C++11/delegating-constructors/>委托构造函数</a><li class=nav-item><a href=/C++11/dynamic-initialization-and-destruction-with-concurrency/>动态初始化和并发析构（魔法静态）</a><li class=nav-item><a href=/C++11/dynamic-pointer-safety/>动态指针安全（垃圾回收接口）</a><li class=nav-item><a href=/C++11/explicit-conversion-operators/>显式转换操作符</a><li class=nav-item><a href=/C++11/extended-friend-declarations/>扩展的friend声明</a><li class=nav-item><a href=/C++11/extern-template/>外部模板</a><li class=nav-item><a href=/C++11/forward-enum-declarations/>前向声明枚举类型</a><li class=nav-item><a href=/C++11/inheriting-constructors/>继承构造函数</a><li class=nav-item><a href=/C++11/initializer-lists/>初始化列表</a><li class=nav-item><a href=/C++11/inline-namespace/>内联名字空间</a><li class=nav-item><a href=/C++11/lambda/>Lambda表达式</a><li class=nav-item><a href=/C++11/local-and-unnamed-types-as-template-parameters/>本地和匿名类型作为模板参数</a><li class=nav-item><a href=/C++11/long-long/>long long类型</a><li class=nav-item><a href=/C++11/money-time-hexfloat-IO-manipulators/>货币、时间、16进制浮点I/O操作</a><li class=nav-item><a href=/C++11/new-characger-type/>新字符类型</a><li class=nav-item><a href=/C++11/noexcept/>noexcept关键字</a><li class=nav-item><a href=/C++11/non-static-data-member-initializers/>非静态数据成员初始化</a><li class=nav-item><a href=/C++11/nullptr/>Nullptr</a><li class=nav-item><a href=/C++11/override-and-final/>override和final关键字</a><li class=nav-item><a href=/C++11/range-for-loop/>基于范围的for循环</a><li class=nav-item><a href=/C++11/raw-string-literals/>原始字面量字符串</a><li class=nav-item><a href=/C++11/ref-qualifiers/>扩展移动语义</a><li class=nav-item><a href=/C++11/right-angle-brackets/>右尖括号</a><li class=nav-item><a href=/C++11/rvalue-ref/>右值引用</a><li class=nav-item><a href=/C++11/static-assert/>静态断言</a><li class=nav-item><a href=/C++11/strongly-typed-enum/>强类型枚举</a><li class=nav-item><a href=/C++11/template-aliases/>模板别名</a><li class=nav-item><a href=/C++11/thread-local-storage/>线程本地存储</a><li class=nav-item><a href=/C++11/trailing-function-return-types/>过滤函数返回类型</a><li class=nav-item><a href=/C++11/type-traits/>类型萃取</a><li class=nav-item><a href=/C++11/unicode-string-literals/>Unicode字面量字符串</a><li class=nav-item><a href=/C++11/unrestricted-unions/>非受限联合体</a><li class=nav-item><a href=/C++11/user-defined-literals/>用户自定义字面量</a><li class=nav-item><a href=/C++11/variadic-templates/>可变参数模板</a></ul><li class="nav-item top-level"><a href=/C++14/binary-literals/>C++14</a><ul><li class=nav-item><a href=/C++14/binary-literals/>二进制字面量</a><li class=nav-item><a href=/C++14/clarifying-memory-allocation/>澄清内存分配</a><li class=nav-item><a href=/C++14/constexpr-for-array/>&lt;array>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-chrono/>&lt;chrono>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-complex/>&lt;complex>的常量表达式</a><li class=nav-item><a href=/C++14/constexpr-for-initializer_list-utility-and-tuple/>&lt;initializer_list>，&lt;utility>和&lt;tuple>的常量表达式</a><li class=nav-item><a href=/C++14/decltype(auto)-return-type-deduction-for-normal-functions/>普通函数返回值类型推导</a><li class=nav-item><a href=/C++14/deprecated-attribute/>废弃的属性</a><li class=nav-item><a href=/C++14/dual-range-std-equal-std-is_permutation-std-mismatch/>双范围的std::equal, std::is_permutation, std::mismatch</a><li class=nav-item><a href=/C++14/extended-constexpr/>扩展常量表达式</a><li class=nav-item><a href=/C++14/fixing-constexpr-member-function-without-const/>修复成员函数常量表达式不能带const修饰</a><li class=nav-item><a href=/C++14/generic-plymorphic-lambda/>Lambda表达式的泛型和多态</a><li class=nav-item><a href=/C++14/heterogeneous-associative-lookup/>关联容器异构比较查找算法</a><li class=nav-item><a href=/C++14/improved-std-integral_constant/>改进std::integral_constant</a><li class=nav-item><a href=/C++14/initialized-generalized-lambda-captures/>初始化和泛化lambda表达式捕获列表</a><li class=nav-item><a href=/C++14/member-initializers-and-aggregates/>成员初始化和聚合</a><li class=nav-item><a href=/C++14/null-forward-iterators/>Null前向迭代器</a><li class=nav-item><a href=/C++14/single-quote-as-digit-separator/>单引号作为数字分隔符</a><li class=nav-item><a href=/C++14/sized-deallocation/>释放指定大小的内存</a><li class=nav-item><a href=/C++14/std-exchange/>std::exchage</a><li class=nav-item><a href=/C++14/std-get_T/>std::get&lt;T>()</a><li class=nav-item><a href=/C++14/std-integer_squence/>std::integer_squence</a><li class=nav-item><a href=/C++14/std-quoted/>std::quoted</a><li class=nav-item><a href=/C++14/std-result_of-and-SFINAE/>std::result_of和SFINAE</a><li class=nav-item><a href=/C++14/std-shared_timed_mutex/>std::shared_timed_mutex</a><li class=nav-item><a href=/C++14/tweaked-wording-for-contextual-conversions/>调整上下文转换</a><li class=nav-item><a href=/C++14/user-defined-literals-for-chrono-and-string/>为chrono和string提供用户自定义字面量</a><li class=nav-item><a href=/C++14/variable-templates/>变量模板</a></ul><li class="nav-item top-level"><a href=/C++17/%5B%5Bfallthrough%5D%5D-attribute/>C++17</a><ul><li class=nav-item><a href=/C++17/%5B%5Bfallthrough%5D%5D-attribute/>[[fallthrough]]属性</a><li class=nav-item><a href=/C++17/%5B%5Bmaybe_unused%5D%5D-attribute/>[[maybe_unused]]属性</a><li class=nav-item><a href=/C++17/%5B%5Bnodiscard%5D%5D-attribute/>[[nodiscard]]属性</a><li class=nav-item><a href=/C++17/aggregate-initialization-of-class-with-base-classes/>聚合带基类的类的初始化</a><li class=nav-item><a href=/C++17/allow-constant-evaluation-for-all-non-type-template-arguments/>允许所有非类型模板参数进行参量计算</a><li class=nav-item><a href=/C++17/attributes-for-namespaces-and-enumerators/>名字空间和枚举的属性</a><li class=nav-item><a href=/C++17/constexpr-if-statements/>if语句常量表达式</a><li class=nav-item><a href=/C++17/constexpr-lambda-expressions/>Lambda常量表达式</a><li class=nav-item><a href=/C++17/differing-begin-and-end-types-in-range-based-for/>基于范围的for循环可以拥有不同类型的begin和end</a><li class=nav-item><a href=/C++17/direct-list-initialization-of-enumerations/>枚举直接列表初始化</a><li class=nav-item><a href=/C++17/dynamic-memory-allocation-for-over-aligned-data/>为过量对齐数据动态分配内存</a><li class=nav-item><a href=/C++17/elementary-string-convertions/>基础字符串转换</a><li class=nav-item><a href=/C++17/fold-expressions/>折叠表达式</a><li class=nav-item><a href=/C++17/guaranteed-copy-elision/>保证复制省略</a><li class=nav-item><a href=/C++17/hexadecimal-floating-point-literals/>16进制浮点字面量</a><li class=nav-item><a href=/C++17/ignore-unknown-attributes/>忽略未知属性</a><li class=nav-item><a href=/C++17/improving-std-pair-and-std-tuple/>改进std::pair和std::tuple</a><li class=nav-item><a href=/C++17/init-statements-for-if-and-switch/>if和switch的初始化语句</a><li class=nav-item><a href=/C++17/inline-variables/>Inline变量</a><li class=nav-item><a href=/C++17/lambda-capture-of-star-this/>Lambda表达式可以捕获*this</a><li class=nav-item><a href=/C++17/make-exception-specifications-part-of-the-type-system/>将异常规范作为类型系统的一部分</a><li class=nav-item><a href=/C++17/matching-of-template-template-arguments-excludes-compatible-templates/>匹配排除兼容模板后的模板模板参数</a><li class=nav-item><a href=/C++17/nested-namespace-definition/>嵌套名字空间定义</a><li class=nav-item><a href=/C++17/new-auto-rules-for-direct-list-initialization/>为直接列表初始化设置新的auto规则</a><li class=nav-item><a href=/C++17/new-specification-for-inheriting-constructors/>继承构造函数的新规范</a><li class=nav-item><a href=/C++17/non-type-template-parameters-with-auto-type/>用auto类型作为无类型的模板参数</a><li class=nav-item><a href=/C++17/pack-expansions-in-using-declarations/>在using声明中使用打包扩张(pack expansion)</a><li class=nav-item><a href=/C++17/remove-deprecated-exception-specifications-from-C++17/>删除C++17中废弃的异常规范</a><li class=nav-item><a href=/C++17/remove-deprecated-operator++(bool)/>删除废弃的operator++(bool)</a><li class=nav-item><a href=/C++17/remove-deprecated-use-of-the-register-keyword/>删除废弃的register关键字</a><li class=nav-item><a href=/C++17/removing-trigraphs/>删除三联符</a><li class=nav-item><a href=/C++17/splicing-maps-and-sets/>拼接map和set</a><li class=nav-item><a href=/C++17/standardization-of-parallelism-ts/>并行的技术规范标准化</a><li class=nav-item><a href=/C++17/static_assert-with-no-message/>无消息的静态断言</a><li class=nav-item><a href=/C++17/std-shared_mutex(untimed)/>std::shared_mutex（untimed）</a><li class=nav-item><a href=/C++17/std-string_view/>std::string_view</a><li class=nav-item><a href=/C++17/std-uncaught_exceptions/>std::uncaught_exceptions</a><li class=nav-item><a href=/C++17/stricter-expression-evaluation-order/>更严格的表达式估值顺序</a><li class=nav-item><a href=/C++17/structured-bindings/>结构化绑定</a><li class=nav-item><a href=/C++17/template-argument-deduction-for-class-template/>类模板的模板参数推导</a><li class=nav-item><a href=/C++17/typename-in-a-template-template-parameter/>模板模板参数中使用typename</a><li class=nav-item><a href=/C++17/u8-character-literals/>u8字符字面量</a><li class=nav-item><a href=/C++17/unary-fold-expressions-and-empty-parameter-pack/>一元折叠表达式和空参打包</a><li class=nav-item><a href=/C++17/using-attribute-namespaces-without-repetition/>不重复地使用带属性的名字空间</a></ul></ul><ul><li class="nav-item top-level"><a href=/changelog/>更新日志</a></ul></nav></header><section class=main><div class=page-header><h2>C++11</h2><h3>C99兼容预处理器</h3></div><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-3435940217424489 data-ad-slot=9166587836 data-ad-format=auto data-full-width-responsive=true></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><article class=content><blockquote><p>编译器支持最低版本要求:<ul><li>GCC: 4.3<li>MSVC: 19.0<li>Clang: Yes</ul><p>提案: <a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1653.htm>N1653</a></blockquote><p>预处理器的改进包括几个方面。<h2 id=扩展整型数据类型>扩展整型数据类型</h2><p>C++11标准只定义了5种有符号整型：<ol><li><code class=highlighter-rouge>signed char</code><li><code class=highlighter-rouge>short int</code><li><code class=highlighter-rouge>int</code><li><code class=highlighter-rouge>long int</code><li><code class=highlighter-rouge>long long int</code>，<a href=../long-long/>此类型为C++11中新引入并标准化</a></ol><p>同时每种有符号整型分别对应一种无符号整型，且对应的两种类型具有相同的存储空间大小。<p>为了满足实际编程中更多的需求，C++11标准允许编译器增加自有的扩展整型数据类型（即使不允许，人家编译器厂商这么多年来也已经这么干了），标准对扩展的类型的名称没有规定，但要求扩展的有符号整型和对应的无符号整型具有相同的存储空间大小。<p>另外，为了能可预期地应对隐式类型转换（类型提升），一般有如下原则的认知：<ul><li>长度越大的整型等级越高<li>长度相同的情况下，标准整型等级高于扩展类型<li>相同大小的有符号类型和无符号类型的等级相同<li>隐式转换时一般按低等级向高等级类型转换，有符号向无符号类型转换</ul><h2 id=混合不同类型字符串字面量的拼接>混合不同类型字符串字面量的拼接</h2><p>C++11一共有5种字符串字面量：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>sz</span> <span class=o>=</span> <span class=s>"hello"</span><span class=p>;</span> <span class=c1>// 窄字符串</span>
<span class=k>const</span> <span class=kt>wchar_t</span> <span class=o>*</span> <span class=n>wsz</span> <span class=o>=</span> <span class=s>L"hello"</span><span class=p>;</span> <span class=c1>// 传统宽字符串</span>
<span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>u8sz</span> <span class=o>=</span> <span class=s>u8"hello"</span><span class=p>;</span>  <span class=c1>// C++11新增UTF-8 编码字符串</span>
<span class=k>const</span> <span class=kt>char16_t</span> <span class=o>*</span> <span class=n>u16sz</span> <span class=o>=</span> <span class=s>u"hello"</span><span class=p>;</span>  <span class=c1>// C++11新增UTF-16 编码字符串</span>
<span class=k>const</span> <span class=kt>char32_t</span> <span class=o>*</span> <span class=n>u32sz</span> <span class=o>=</span> <span class=s>U"hello"</span><span class=p>;</span>  <span class=c1>// C++11新增UTF-32 编码字符串</span>
</code></pre></div></div><p>除了第一种是窄字符串外，另外几种都算宽字符串，后三种是对第二种的扩展。<p>在C++中两个连续的同类型字符串字面量会自动拼接成一个：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>sz</span> <span class=o>=</span> <span class=s>"hello"</span> <span class=s>" world"</span><span class=p>;</span> <span class=c1>// 相当于赋值"hello world";</span>
</code></pre></div></div><p>但是在C++11之前，宽窄不同类型字符串字面量放在一起，则是未定义行为：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>const</span> <span class=kt>wchar_t</span> <span class=o>*</span> <span class=n>sz</span> <span class=o>=</span> <span class=s>"hello"</span> <span class=s>L" world"</span><span class=p>;</span> <span class=c1>// C++98/03未定义行为，C++11则以宽字符串字面量拼接</span>
</code></pre></div></div><p>上式在C++11中则以宽字符串字面量拼接，相当于赋值<code class=highlighter-rouge>L"hello world"</code>。C++11中多个字符串字面量连续定义的，不带前缀的字符串字面量全部转为带前缀的字符串字面量，比如：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>sz1</span> <span class=o>=</span> <span class=s>"hello"</span> <span class=s>u" world"</span><span class=p>;</span> <span class=c1>// 相当于赋值u"hello world"</span>
<span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>sz2</span> <span class=o>=</span> <span class=s>u"hello"</span> <span class=s>" world"</span><span class=p>;</span> <span class=c1>// 相当于赋值u"hello world"</span>
</code></pre></div></div><p>不同类型字符串字面量的拼接也有些限制：<ol><li>UTF-8和宽字符串字面量同时声明会有冲突<li>其他带前缀的多个字符串字面量连接定义行为未标准化，由编译器自行定义实现</ol><h2 id=诊断include包含的头文件的名字>诊断<code class=highlighter-rouge>#include</code>包含的头文件的名字</h2><p>是个奇怪的特性，如果<code class=highlighter-rouge>#include</code>语句后面包含的头文件（路径）第一个字符是个数字，则编译器会警告，比如：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>// inc.cpp</span>

<span class=cp>#include "0x/header.h"
</span></code></pre></div></div><p>这个代码编译时大概会输出如下的警告：<div class=highlighter-rouge><div class=highlight><pre class=highlight><code>"inc.cpp", line 1.10: 1540-0893 (W) The header file name "0x/header.h" 
in #include directive shall not start with a digit.
</code></pre></div></div><p>好像没什么用。<h2 id=增加line预处理指令的上限>增加<code class=highlighter-rouge>#line</code>预处理指令的上限</h2><p><code class=highlighter-rouge>#line</code>可以重新设置当前源代码文件的行号和文件名（用于编译器warning，error之类消息输出定位）。在C++11之前，<code class=highlighter-rouge>#line</code>可设置的行号最大值是<code class=highlighter-rouge>32767</code>，在C++11中调整为<code class=highlighter-rouge>2147483647</code>。<h2 id=诊断对象类的宏定义>诊断对象类的宏定义</h2><h2 id=_pragma操作符><code class=highlighter-rouge>_Pragma</code>操作符</h2><p>C++标准中<code class=highlighter-rouge>#pragma</code>预处理器指令可以用来向编译器传递一些语言标准以外的信息，比如：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=cp>#pragma once   // 该文件只被编译一遍，一般用于头文件中
#pragma comment(lib, "user32") // 本文件代码依赖user32.lib，链接时会自动寻找并链接
#pragma warning(disable: 4996) // 禁止上报编号为4996的编译器警告
</span></code></pre></div></div><p>C++11增加了<code class=highlighter-rouge>_Pragma</code><strong>操作符</strong>，提供了跟<code class=highlighter-rouge>#pragma</code><strong>几乎相同</strong>的功能，格式为：<code class=highlighter-rouge>_Pragma(字符串字面量)</code>。所以上面的<code class=highlighter-rouge>#pragma</code>示例可以用<code class=highlighter-rouge>_Pragma</code>改写为：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>_Pragma</span><span class=p>(</span><span class=s>"once"</span><span class=p>);</span>
<span class=n>_Pragma</span><span class=p>(</span><span class=s>"comment(lib, </span><span class=se>\"</span><span class=s>user32</span><span class=se>\"</span><span class=s>)"</span><span class=p>);</span>
<span class=n>_Pragma</span><span class=p>(</span><span class=s>"warning(disable: 4996)"</span><span class=p>);</span>
</code></pre></div></div><p>用<code class=highlighter-rouge>_Pragma</code>而不用<code class=highlighter-rouge>#pragma</code>的好处是<code class=highlighter-rouge>_Pragma</code>是个操作符，所以可以用于宏定义中，而<code class=highlighter-rouge>#pragma</code>不行：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=cp>#define COMPILED_ONCE _Pragma("once")
</span></code></pre></div></div><h2 id=变长参数宏定义>变长参数宏定义</h2><p>C++11增加了<code class=highlighter-rouge>__VA_ARGS__</code>用于处理变长参数的宏定义：<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=cp>#define PR(...) printf(__VA_ARGS__)
</span></code></pre></div></div><p>看来唯一的作用就是把宏定义的变长参数转为函数的变长参数。<h2 id=预定义宏>预定义宏</h2><p>C++11新增4个与C99兼容的预定义宏：<table><thead><tr><th style=text-align:right>宏名称<th>功能<tbody><tr><td style=text-align:right><code class=highlighter-rouge>__STDC__</code><td>当前编译器是否和C标准实现一致，是否定义以及定义成什么值由编译器决定。<tr><td style=text-align:right><code class=highlighter-rouge>__STDC_VERSION__</code><td>当前编译器支持的C标准的版本，比如<code class=highlighter-rouge>1999mmL</code>，是否定义以及定义成什么值由编译器决定。<tr><td style=text-align:right><code class=highlighter-rouge>__STDC_ISO_10646__</code><td>当前编译器是否符合某个版本的ISO/IEC 10646标准，比如<code class=highlighter-rouge>199712L</code>，是否定义以及定义成什么值由编译器决定。<tr><td style=text-align:right><code class=highlighter-rouge>__STDC_HOSTED__</code><td>当前编译器环境是否带有完整的标准C库，非0即1。</table><p>除此之外，C++11例行更新了<code class=highlighter-rouge>__cplusplus</code>的值为<code class=highlighter-rouge>201103L</code>，因此可以根据这个宏来判断当前编译环境是否支持C++11:<div class="language-c++ highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=cp>#if __cplusplus &lt; 201103L
</span>    <span class=cp>#error "C++11 is needed"
#endif
</span></code></pre></div></div><p>另外，C++11标准化了预定义标识符<code class=highlighter-rouge>__func__</code>，尽管有些编译器老就支持了。<code class=highlighter-rouge>__func__</code>代表所在函数的名字字符串，因此如果用在函数未定义的位置（比如在函数声明的参数列表处作为参数缺少值）是编译不通过的。<p>常见编译器（MSVC除外，求告知！）缺省预定义宏可以通过命令行查看：<table><thead><tr><th>编译器<th>查看C++预定义宏命令(注意添加相对应的C++标准版命令行参数)<tbody><tr><td>Clang/LLVM<td>clang++ -dM -E -x c++ /dev/null<tr><td>GCC<td>g++ -dM -E -x c++ /dev/null<tr><td>HP C/aC++<td>aCC -dM -E -x c++ /dev/null<tr><td>IBM XL C/C++<td>xlc++ -qshowmacros -E /dev/null<tr><td>Intel C++<td>icpc -dM -E -x c++ /dev/null<tr><td>Oracle Solaris Studio<td>CC -xdumpmacros -E /dev/null</table><p>​</article><div class=content><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div style=line-height:2.5>感觉不错，小额赞助一下！</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>打赏</span></button><div id=QR style=display:block><div id=wechat style=display:inline-block><a href=wxp://f2f0JOwB8LU7CU53fcitPGIuC6lYMX1q-nlk class=fancybox rel=group><img id=wechat_qr src=https://blogassets.ismisv.com/assets/images/wepay.jpg alt="missdeer WeChat Pay"></a><p>微信扫一扫</div><div id=wechat style=display:inline-block><a href="alipays://platformapi/startapp?appId=10000007&qrcode=https://qr.alipay.com/tsx00458kzwvymgbjk0ci9e" class=fancybox rel=group><img id=alipay_qr src=https://blogassets.ismisv.com/assets/images/alipay.jpg alt="missdeer AliPay"></a><p>支付宝扫一扫</div></div></div></div><div class=content></hr><div style=color:#b3b3b3;font-size:.7em><p>Hosted by <a href=https://app.netlify.com/ style=font-weight:700>Netlify</a>,
本站由 <a href=https://minidump.info target=_blank>@missdeer</a> 创建，由 <a href=https://jekyllrb.com target=_blank>Jekyll</a> 于 2024-11-07 生成，感谢<a href=https://github.com/CloudCannon target=_blank> CloudCannon </a>制作的theme： <a href=https://github.com/CloudCannon/edition-jekyll-template target=_blank>Edition</a> ，感谢<a href=https://letsencrypt.org/ target=_blank> Let's Encrypt </a>提供免费的SSL证书服务。本站点采用<a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>知识共享署名-非商业性使用-相同方式共享
4.0 国际许可协议</a>进行许可。&copy; 2017 - 2024</div></div></section><script>document.getElementById("open-nav").addEventListener("click",function(){document.body.classList.toggle("nav-open")})</script>